{"ast":null,"code":"\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction arrayifyInteger(value) {\n  const result = [];\n  while (value) {\n    result.unshift(value & 0xff);\n    value >>= 8;\n  }\n  return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _encode(object) {\n  if (Array.isArray(object)) {\n    let payload = [];\n    object.forEach(function (child) {\n      payload = payload.concat(_encode(child));\n    });\n    if (payload.length <= 55) {\n      payload.unshift(0xc0 + payload.length);\n      return payload;\n    }\n    const length = arrayifyInteger(payload.length);\n    length.unshift(0xf7 + length.length);\n    return length.concat(payload);\n  }\n  if (!isBytesLike(object)) {\n    logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n  }\n  const data = Array.prototype.slice.call(arrayify(object));\n  if (data.length === 1 && data[0] <= 0x7f) {\n    return data;\n  } else if (data.length <= 55) {\n    data.unshift(0x80 + data.length);\n    return data;\n  }\n  const length = arrayifyInteger(data.length);\n  length.unshift(0xb7 + length.length);\n  return length.concat(data);\n}\nexport function encode(object) {\n  return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    if (childOffset > offset + 1 + length) {\n      logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  if (data.length === 0) {\n    logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n  }\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n    if (offset + 1 + length > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n    if (offset + 1 + length > data.length) {\n      logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlify(data[offset])\n  };\n}\nexport function decode(data) {\n  const bytes = arrayify(data);\n  const decoded = _decode(bytes, 0);\n  if (decoded.consumed !== bytes.length) {\n    logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n  }\n  return decoded.result;\n}","map":{"version":3,"names":["arrayify","hexlify","isBytesLike","Logger","version","logger","arrayifyInteger","value","result","unshift","unarrayifyInteger","data","offset","length","i","_encode","object","Array","isArray","payload","forEach","child","concat","throwArgumentError","prototype","slice","call","encode","_decodeChildren","childOffset","decoded","_decode","push","consumed","throwError","errors","BUFFER_OVERRUN","lengthLength","decode","bytes"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\ethers\\node_modules\\@ethersproject\\rlp\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n"],"mappings":"AAAA,YAAY;;AAEZ;AAEA,SAASA,QAAQ,EAAaC,OAAO,EAAEC,WAAW,QAAQ,sBAAsB;AAEhF,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,OAAO,QAAQ,YAAY;AACpC,MAAMC,MAAM,GAAG,IAAIF,MAAM,CAACC,OAAO,CAAC;AAElC,SAASE,eAAeA,CAACC,KAAa;EAClC,MAAMC,MAAM,GAAG,EAAE;EACjB,OAAOD,KAAK,EAAE;IACVC,MAAM,CAACC,OAAO,CAACF,KAAK,GAAG,IAAI,CAAC;IAC5BA,KAAK,KAAK,CAAC;;EAEf,OAAOC,MAAM;AACjB;AAEA,SAASE,iBAAiBA,CAACC,IAAgB,EAAEC,MAAc,EAAEC,MAAc;EACvE,IAAIL,MAAM,GAAG,CAAC;EACd,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,EAAEC,CAAC,EAAE,EAAE;IAC7BN,MAAM,GAAIA,MAAM,GAAG,GAAG,GAAIG,IAAI,CAACC,MAAM,GAAGE,CAAC,CAAC;;EAE9C,OAAON,MAAM;AACjB;AAEA,SAASO,OAAOA,CAACC,MAA2B;EACxC,IAAIC,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;IACvB,IAAIG,OAAO,GAAkB,EAAE;IAC/BH,MAAM,CAACI,OAAO,CAAC,UAASC,KAAK;MACzBF,OAAO,GAAGA,OAAO,CAACG,MAAM,CAACP,OAAO,CAACM,KAAK,CAAC,CAAC;IAC5C,CAAC,CAAC;IAEF,IAAIF,OAAO,CAACN,MAAM,IAAI,EAAE,EAAE;MACtBM,OAAO,CAACV,OAAO,CAAC,IAAI,GAAGU,OAAO,CAACN,MAAM,CAAC;MACtC,OAAOM,OAAO;;IAGlB,MAAMN,MAAM,GAAGP,eAAe,CAACa,OAAO,CAACN,MAAM,CAAC;IAC9CA,MAAM,CAACJ,OAAO,CAAC,IAAI,GAAGI,MAAM,CAACA,MAAM,CAAC;IAEpC,OAAOA,MAAM,CAACS,MAAM,CAACH,OAAO,CAAC;;EAIjC,IAAI,CAACjB,WAAW,CAACc,MAAM,CAAC,EAAE;IACtBX,MAAM,CAACkB,kBAAkB,CAAC,8BAA8B,EAAE,QAAQ,EAAEP,MAAM,CAAC;;EAG/E,MAAML,IAAI,GAAkBM,KAAK,CAACO,SAAS,CAACC,KAAK,CAACC,IAAI,CAAC1B,QAAQ,CAACgB,MAAM,CAAC,CAAC;EAExE,IAAIL,IAAI,CAACE,MAAM,KAAK,CAAC,IAAIF,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;IACtC,OAAOA,IAAI;GAEd,MAAM,IAAIA,IAAI,CAACE,MAAM,IAAI,EAAE,EAAE;IAC1BF,IAAI,CAACF,OAAO,CAAC,IAAI,GAAGE,IAAI,CAACE,MAAM,CAAC;IAChC,OAAOF,IAAI;;EAGf,MAAME,MAAM,GAAGP,eAAe,CAACK,IAAI,CAACE,MAAM,CAAC;EAC3CA,MAAM,CAACJ,OAAO,CAAC,IAAI,GAAGI,MAAM,CAACA,MAAM,CAAC;EAEpC,OAAOA,MAAM,CAACS,MAAM,CAACX,IAAI,CAAC;AAC9B;AAEA,OAAM,SAAUgB,MAAMA,CAACX,MAAW;EAC9B,OAAOf,OAAO,CAACc,OAAO,CAACC,MAAM,CAAC,CAAC;AACnC;AAOA,SAASY,eAAeA,CAACjB,IAAgB,EAAEC,MAAc,EAAEiB,WAAmB,EAAEhB,MAAc;EAC1F,MAAML,MAAM,GAAG,EAAE;EAEjB,OAAOqB,WAAW,GAAGjB,MAAM,GAAG,CAAC,GAAGC,MAAM,EAAE;IACtC,MAAMiB,OAAO,GAAGC,OAAO,CAACpB,IAAI,EAAEkB,WAAW,CAAC;IAE1CrB,MAAM,CAACwB,IAAI,CAACF,OAAO,CAACtB,MAAM,CAAC;IAE3BqB,WAAW,IAAIC,OAAO,CAACG,QAAQ;IAC/B,IAAIJ,WAAW,GAAGjB,MAAM,GAAG,CAAC,GAAGC,MAAM,EAAE;MACnCR,MAAM,CAAC6B,UAAU,CAAC,sBAAsB,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;;EAIpF,OAAO;IAACH,QAAQ,EAAG,CAAC,GAAGpB,MAAO;IAAEL,MAAM,EAAEA;EAAM,CAAC;AACnD;AAEA;AACA,SAASuB,OAAOA,CAACpB,IAAgB,EAAEC,MAAc;EAC7C,IAAID,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;IACnBR,MAAM,CAAC6B,UAAU,CAAC,gBAAgB,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;EAG1E;EACA,IAAIzB,IAAI,CAACC,MAAM,CAAC,IAAI,IAAI,EAAE;IACtB,MAAMyB,YAAY,GAAG1B,IAAI,CAACC,MAAM,CAAC,GAAG,IAAI;IACxC,IAAIA,MAAM,GAAG,CAAC,GAAGyB,YAAY,GAAG1B,IAAI,CAACE,MAAM,EAAE;MACzCR,MAAM,CAAC6B,UAAU,CAAC,8BAA8B,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;IAGxF,MAAMvB,MAAM,GAAGH,iBAAiB,CAACC,IAAI,EAAEC,MAAM,GAAG,CAAC,EAAEyB,YAAY,CAAC;IAChE,IAAIzB,MAAM,GAAG,CAAC,GAAGyB,YAAY,GAAGxB,MAAM,GAAGF,IAAI,CAACE,MAAM,EAAE;MAClDR,MAAM,CAAC6B,UAAU,CAAC,6BAA6B,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;IAGvF,OAAOR,eAAe,CAACjB,IAAI,EAAEC,MAAM,EAAEA,MAAM,GAAG,CAAC,GAAGyB,YAAY,EAAEA,YAAY,GAAGxB,MAAM,CAAC;GAEzF,MAAM,IAAIF,IAAI,CAACC,MAAM,CAAC,IAAI,IAAI,EAAE;IAC7B,MAAMC,MAAM,GAAGF,IAAI,CAACC,MAAM,CAAC,GAAG,IAAI;IAClC,IAAIA,MAAM,GAAG,CAAC,GAAGC,MAAM,GAAGF,IAAI,CAACE,MAAM,EAAE;MACnCR,MAAM,CAAC6B,UAAU,CAAC,sBAAsB,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;IAGhF,OAAOR,eAAe,CAACjB,IAAI,EAAEC,MAAM,EAAEA,MAAM,GAAG,CAAC,EAAEC,MAAM,CAAC;GAE3D,MAAM,IAAIF,IAAI,CAACC,MAAM,CAAC,IAAI,IAAI,EAAE;IAC7B,MAAMyB,YAAY,GAAG1B,IAAI,CAACC,MAAM,CAAC,GAAG,IAAI;IACxC,IAAIA,MAAM,GAAG,CAAC,GAAGyB,YAAY,GAAG1B,IAAI,CAACE,MAAM,EAAE;MACzCR,MAAM,CAAC6B,UAAU,CAAC,sBAAsB,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;IAGhF,MAAMvB,MAAM,GAAGH,iBAAiB,CAACC,IAAI,EAAEC,MAAM,GAAG,CAAC,EAAEyB,YAAY,CAAC;IAChE,IAAIzB,MAAM,GAAG,CAAC,GAAGyB,YAAY,GAAGxB,MAAM,GAAGF,IAAI,CAACE,MAAM,EAAE;MAClDR,MAAM,CAAC6B,UAAU,CAAC,sBAAsB,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;IAGhF,MAAM5B,MAAM,GAAGP,OAAO,CAACU,IAAI,CAACc,KAAK,CAACb,MAAM,GAAG,CAAC,GAAGyB,YAAY,EAAEzB,MAAM,GAAG,CAAC,GAAGyB,YAAY,GAAGxB,MAAM,CAAC,CAAC;IACjG,OAAO;MAAEoB,QAAQ,EAAG,CAAC,GAAGI,YAAY,GAAGxB,MAAO;MAAEL,MAAM,EAAEA;IAAM,CAAE;GAEnE,MAAM,IAAIG,IAAI,CAACC,MAAM,CAAC,IAAI,IAAI,EAAE;IAC7B,MAAMC,MAAM,GAAGF,IAAI,CAACC,MAAM,CAAC,GAAG,IAAI;IAClC,IAAIA,MAAM,GAAG,CAAC,GAAGC,MAAM,GAAGF,IAAI,CAACE,MAAM,EAAE;MACnCR,MAAM,CAAC6B,UAAU,CAAC,gBAAgB,EAAE/B,MAAM,CAACgC,MAAM,CAACC,cAAc,EAAE,EAAG,CAAC;;IAG1E,MAAM5B,MAAM,GAAGP,OAAO,CAACU,IAAI,CAACc,KAAK,CAACb,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAG,CAAC,GAAGC,MAAM,CAAC,CAAC;IACnE,OAAO;MAAEoB,QAAQ,EAAG,CAAC,GAAGpB,MAAO;MAAEL,MAAM,EAAEA;IAAM,CAAE;;EAErD,OAAO;IAAEyB,QAAQ,EAAE,CAAC;IAAEzB,MAAM,EAAEP,OAAO,CAACU,IAAI,CAACC,MAAM,CAAC;EAAC,CAAE;AACzD;AAEA,OAAM,SAAU0B,MAAMA,CAAC3B,IAAe;EAClC,MAAM4B,KAAK,GAAGvC,QAAQ,CAACW,IAAI,CAAC;EAC5B,MAAMmB,OAAO,GAAGC,OAAO,CAACQ,KAAK,EAAE,CAAC,CAAC;EACjC,IAAIT,OAAO,CAACG,QAAQ,KAAKM,KAAK,CAAC1B,MAAM,EAAE;IACnCR,MAAM,CAACkB,kBAAkB,CAAC,kBAAkB,EAAE,MAAM,EAAEZ,IAAI,CAAC;;EAE/D,OAAOmB,OAAO,CAACtB,MAAM;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}