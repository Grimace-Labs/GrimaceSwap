{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  _throwError(message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  }\n}\nexport class Writer {\n  constructor(wordSize) {\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n  get data() {\n    return hexConcat(this._data);\n  }\n  get length() {\n    return this._dataLength;\n  }\n  _writeData(data) {\n    this._data.push(data);\n    this._dataLength += data.length;\n    return data.length;\n  }\n  appendWriter(writer) {\n    return this._writeData(concat(writer._data));\n  }\n  // Arrayish items; padded on the right to wordSize\n  writeBytes(value) {\n    let bytes = arrayify(value);\n    const paddingOffset = bytes.length % this.wordSize;\n    if (paddingOffset) {\n      bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n    }\n    return this._writeData(bytes);\n  }\n  _getValue(value) {\n    let bytes = arrayify(BigNumber.from(value));\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n    if (bytes.length % this.wordSize) {\n      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n    return bytes;\n  }\n  // BigNumberish items; padded on the left to wordSize\n  writeValue(value) {\n    return this._writeData(this._getValue(value));\n  }\n  writeUpdatableValue() {\n    const offset = this._data.length;\n    this._data.push(this._padding);\n    this._dataLength += this.wordSize;\n    return value => {\n      this._data[offset] = this._getValue(value);\n    };\n  }\n}\nexport class Reader {\n  constructor(data, wordSize, coerceFunc, allowLoose) {\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n  get data() {\n    return hexlify(this._data);\n  }\n  get consumed() {\n    return this._offset;\n  }\n  // The default Coerce function\n  static coerce(name, value) {\n    let match = name.match(\"^u?int([0-9]+)$\");\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n    return value;\n  }\n  coerce(name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n    return Reader.coerce(name, value);\n  }\n  _peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n    if (this._offset + alignedLength > this._data.length) {\n      if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n        alignedLength = length;\n      } else {\n        logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this._data.length,\n          offset: this._offset + alignedLength\n        });\n      }\n    }\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  }\n  subReader(offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n  }\n  readBytes(length, loose) {\n    let bytes = this._peekBytes(0, length, !!loose);\n    this._offset += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  readValue() {\n    return BigNumber.from(this.readBytes(this.wordSize));\n  }\n}","map":{"version":3,"names":["arrayify","concat","hexConcat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","constructor","name","type","localName","dynamic","_throwError","message","value","throwArgumentError","Writer","wordSize","_data","_dataLength","_padding","Uint8Array","data","length","_writeData","appendWriter","writer","writeBytes","bytes","paddingOffset","_getValue","from","throwError","BUFFER_OVERRUN","offset","writeValue","writeUpdatableValue","Reader","coerceFunc","allowLoose","_offset","consumed","coerce","match","parseInt","toNumber","_coerceFunc","_peekBytes","loose","alignedLength","Math","ceil","subReader","readBytes","readValue"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\abi\\src.ts\\coders\\abstract-coder.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}