{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Exported Types\nfunction hasMnemonic(value) {\n  return value != null && value.mnemonic && value.mnemonic.phrase;\n}\nexport class KeystoreAccount extends Description {\n  isKeystoreAccount(value) {\n    return !!(value && value._isKeystoreAccount);\n  }\n}\nfunction _decrypt(data, key, ciphertext) {\n  const cipher = searchPath(data, \"crypto/cipher\");\n  if (cipher === \"aes-128-ctr\") {\n    const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n    const counter = new aes.Counter(iv);\n    const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n    return arrayify(aesCtr.decrypt(ciphertext));\n  }\n  return null;\n}\nfunction _getAccount(data, key) {\n  const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n  if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n    throw new Error(\"invalid password\");\n  }\n  const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n  if (!privateKey) {\n    logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"decrypt\"\n    });\n  }\n  const mnemonicKey = key.slice(32, 64);\n  const address = computeAddress(privateKey);\n  if (data.address) {\n    let check = data.address.toLowerCase();\n    if (check.substring(0, 2) !== \"0x\") {\n      check = \"0x\" + check;\n    }\n    if (getAddress(check) !== address) {\n      throw new Error(\"address mismatch\");\n    }\n  }\n  const account = {\n    _isKeystoreAccount: true,\n    address: address,\n    privateKey: hexlify(privateKey)\n  };\n  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n  if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n    const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n    const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n    const mnemonicCounter = new aes.Counter(mnemonicIv);\n    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n    const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n    const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n    try {\n      const mnemonic = entropyToMnemonic(entropy, locale);\n      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n      account.mnemonic = node.mnemonic;\n    } catch (error) {\n      // If we don't have the locale wordlist installed to\n      // read this mnemonic, just bail and don't set the\n      // mnemonic\n      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n        throw error;\n      }\n    }\n  }\n  return new KeystoreAccount(account);\n}\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n  return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n  const passwordBytes = getPassword(password);\n  const kdf = searchPath(data, \"crypto/kdf\");\n  if (kdf && typeof kdf === \"string\") {\n    const throwError = function (name, value) {\n      return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n    };\n    if (kdf.toLowerCase() === \"scrypt\") {\n      const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n      const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n      const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n      // Check for all required parameters\n      if (!N || !r || !p) {\n        throwError(\"kdf\", kdf);\n      }\n      // Make sure N is a power of 2\n      if ((N & N - 1) !== 0) {\n        throwError(\"N\", N);\n      }\n      const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      let prfFunc = null;\n      const prf = searchPath(data, \"crypto/kdfparams/prf\");\n      if (prf === \"hmac-sha256\") {\n        prfFunc = \"sha256\";\n      } else if (prf === \"hmac-sha512\") {\n        prfFunc = \"sha512\";\n      } else {\n        throwError(\"prf\", prf);\n      }\n      const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n      const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n    }\n  }\n  return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\nexport function decryptSync(json, password) {\n  const data = JSON.parse(json);\n  const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n  return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const data = JSON.parse(json);\n    const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n  });\n}\nexport function encrypt(account, password, options, progressCallback) {\n  try {\n    // Check the address matches the private key\n    if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n      throw new Error(\"address/privateKey mismatch\");\n    }\n    // Check the mnemonic (if any) matches the private key\n    if (hasMnemonic(account)) {\n      const mnemonic = account.mnemonic;\n      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  // The options are optional, so adjust the call as needed\n  if (typeof options === \"function\" && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n  if (!options) {\n    options = {};\n  }\n  const privateKey = arrayify(account.privateKey);\n  const passwordBytes = getPassword(password);\n  let entropy = null;\n  let path = null;\n  let locale = null;\n  if (hasMnemonic(account)) {\n    const srcMnemonic = account.mnemonic;\n    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n    path = srcMnemonic.path || defaultPath;\n    locale = srcMnemonic.locale || \"en\";\n  }\n  let client = options.client;\n  if (!client) {\n    client = \"ethers.js\";\n  }\n  // Check/generate the salt\n  let salt = null;\n  if (options.salt) {\n    salt = arrayify(options.salt);\n  } else {\n    salt = randomBytes(32);\n    ;\n  }\n  // Override initialization vector\n  let iv = null;\n  if (options.iv) {\n    iv = arrayify(options.iv);\n    if (iv.length !== 16) {\n      throw new Error(\"invalid iv\");\n    }\n  } else {\n    iv = randomBytes(16);\n  }\n  // Override the uuid\n  let uuidRandom = null;\n  if (options.uuid) {\n    uuidRandom = arrayify(options.uuid);\n    if (uuidRandom.length !== 16) {\n      throw new Error(\"invalid uuid\");\n    }\n  } else {\n    uuidRandom = randomBytes(16);\n  }\n  // Override the scrypt password-based key derivation function parameters\n  let N = 1 << 17,\n    r = 8,\n    p = 1;\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  }\n  // We take 64 bytes:\n  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n  return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(key => {\n    key = arrayify(key);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n    // This will be used to encrypt the mnemonic phrase (if any)\n    const mnemonicKey = key.slice(32, 64);\n    // Encrypt the private key\n    const counter = new aes.Counter(iv);\n    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n    const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    const mac = keccak256(concat([macPrefix, ciphertext]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data = {\n      address: account.address.substring(2).toLowerCase(),\n      id: uuidV4(uuidRandom),\n      version: 3,\n      Crypto: {\n        cipher: \"aes-128-ctr\",\n        cipherparams: {\n          iv: hexlify(iv).substring(2)\n        },\n        ciphertext: hexlify(ciphertext).substring(2),\n        kdf: \"scrypt\",\n        kdfparams: {\n          salt: hexlify(salt).substring(2),\n          n: N,\n          dklen: 32,\n          p: p,\n          r: r\n        },\n        mac: mac.substring(2)\n      }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (entropy) {\n      const mnemonicIv = randomBytes(16);\n      const mnemonicCounter = new aes.Counter(mnemonicIv);\n      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n      const now = new Date();\n      const timestamp = now.getUTCFullYear() + \"-\" + zpad(now.getUTCMonth() + 1, 2) + \"-\" + zpad(now.getUTCDate(), 2) + \"T\" + zpad(now.getUTCHours(), 2) + \"-\" + zpad(now.getUTCMinutes(), 2) + \"-\" + zpad(now.getUTCSeconds(), 2) + \".0Z\";\n      data[\"x-ethers\"] = {\n        client: client,\n        gethFilename: \"UTC--\" + timestamp + \"--\" + data.address,\n        mnemonicCounter: hexlify(mnemonicIv).substring(2),\n        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n        path: path,\n        locale: locale,\n        version: \"0.1\"\n      };\n    }\n    return JSON.stringify(data);\n  });\n}","map":{"version":3,"names":["aes","scrypt","getAddress","arrayify","concat","hexlify","defaultPath","entropyToMnemonic","HDNode","mnemonicToEntropy","keccak256","pbkdf2","_pbkdf2","randomBytes","Description","computeAddress","getPassword","looseArrayify","searchPath","uuidV4","zpad","Logger","version","logger","hasMnemonic","value","mnemonic","phrase","KeystoreAccount","isKeystoreAccount","_isKeystoreAccount","_decrypt","data","key","ciphertext","cipher","iv","counter","Counter","aesCtr","ModeOfOperation","ctr","decrypt","_getAccount","computedMAC","slice","substring","toLowerCase","Error","privateKey","throwError","errors","UNSUPPORTED_OPERATION","operation","mnemonicKey","address","check","account","mnemonicCiphertext","mnemonicIv","mnemonicCounter","mnemonicAesCtr","path","locale","entropy","node","fromMnemonic","derivePath","error","code","INVALID_ARGUMENT","argument","pbkdf2Sync","passwordBytes","salt","count","dkLen","prfFunc","Promise","resolve","_computeKdfKey","password","pbkdf2Func","scryptFunc","progressCallback","kdf","name","throwArgumentError","N","parseInt","r","p","prf","decryptSync","json","JSON","parse","syncScrypt","encrypt","options","e","reject","srcMnemonic","client","length","uuidRandom","uuid","then","derivedKey","macPrefix","mac","id","Crypto","cipherparams","kdfparams","n","dklen","now","Date","timestamp","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","stringify"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\json-wallets\\src.ts\\keystore.ts"],"sourcesContent":["\"use strict\";\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\n\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Exported Types\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\n\nexport interface _KeystoreAccount {\n    address: string;\n    privateKey: string;\n    mnemonic?: Mnemonic;\n\n    _isKeystoreAccount: boolean;\n}\n\nexport class KeystoreAccount extends Description<_KeystoreAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: Mnemonic;\n\n    readonly _isKeystoreAccount: boolean;\n\n    isKeystoreAccount(value: any): value is KeystoreAccount {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\n\nexport type ProgressCallback = (percent: number) => void;\n\nexport type EncryptOptions = {\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\nfunction _decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"))\n        const counter = new aes.Counter(iv);\n\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n}\n\nfunction _getAccount(data: any, key: Uint8Array): KeystoreAccount {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n\n    const mnemonicKey = key.slice(32, 64);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") { check = \"0x\" + check; }\n\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n\n    const account: _KeystoreAccount = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n\n            account.mnemonic = node.mnemonic;\n\n        } catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n\n    return new KeystoreAccount(account);\n}\n\ntype ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p: number, dkLen: number, callback?: ProgressCallback) => T;\ntype Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;\n\nfunction pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {\n    const passwordBytes = getPassword(password);\n\n    const kdf = searchPath(data, \"crypto/kdf\");\n\n    if (kdf && typeof(kdf) === \"string\") {\n        const throwError = function(name: string, value: any): never {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        }\n\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n\n            // Check for all required parameters\n            if (!N || !r || !p) { throwError(\"kdf\", kdf); }\n\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) { throwError(\"N\", N); }\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n\n            let prfFunc: string = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            } else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            } else {\n                throwError(\"prf\", prf);\n            }\n\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\nexport function decryptSync(json: string, password: Bytes | string): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\n\nexport async function decrypt(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const key = await _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n}\n\n\nexport function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {\n\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n\n    } catch (e) {\n        return Promise.reject(e);\n    }\n\n    // The options are optional, so adjust the call as needed\n    if (typeof(options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) { options = {}; }\n\n    const privateKey: Uint8Array = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n\n    let entropy: Uint8Array = null\n    let path: string = null;\n    let locale: string = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n\n    let client = options.client;\n    if (!client) { client = \"ethers.js\"; }\n\n    // Check/generate the salt\n    let salt: Uint8Array = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    } else {\n        salt = randomBytes(32);;\n    }\n\n    // Override initialization vector\n    let iv: Uint8Array = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) { throw new Error(\"invalid iv\"); }\n    } else {\n       iv = randomBytes(16);\n    }\n\n    // Override the uuid\n    let uuidRandom: Uint8Array = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) { throw new Error(\"invalid uuid\"); }\n    } else {\n        uuidRandom = randomBytes(16);\n    }\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]))\n\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data: { [key: string]: any } = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuidV4(uuidRandom),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                               zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                               zpad(now.getUTCDate(), 2) + \"T\" +\n                               zpad(now.getUTCHours(), 2) + \"-\" +\n                               zpad(now.getUTCMinutes(), 2) + \"-\" +\n                               zpad(now.getUTCSeconds(), 2) + \".0Z\"\n                              );\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n\n        return JSON.stringify(data);\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}