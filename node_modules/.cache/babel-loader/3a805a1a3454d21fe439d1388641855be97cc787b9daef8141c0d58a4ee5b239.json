{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nvar logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexport var Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      logger.throwArgumentError(message, this.localName, value);\n    }\n  }]);\n  return Coder;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer(wordSize) {\n    _classCallCheck(this, Writer);\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n  _createClass(Writer, [{\n    key: \"data\",\n    get: function get() {\n      return hexConcat(this._data);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._dataLength;\n    }\n  }, {\n    key: \"_writeData\",\n    value: function _writeData(data) {\n      this._data.push(data);\n      this._dataLength += data.length;\n      return data.length;\n    }\n  }, {\n    key: \"appendWriter\",\n    value: function appendWriter(writer) {\n      return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = arrayify(value);\n      var paddingOffset = bytes.length % this.wordSize;\n      if (paddingOffset) {\n        bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n      }\n      return this._writeData(bytes);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(value) {\n      var bytes = arrayify(BigNumber.from(value));\n      if (bytes.length > this.wordSize) {\n        logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this.wordSize,\n          offset: bytes.length\n        });\n      }\n      if (bytes.length % this.wordSize) {\n        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n      }\n      return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return this._writeData(this._getValue(value));\n    }\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this = this;\n      var offset = this._data.length;\n      this._data.push(this._padding);\n      this._dataLength += this.wordSize;\n      return function (value) {\n        _this._data[offset] = _this._getValue(value);\n      };\n    }\n  }]);\n  return Writer;\n}();\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data, wordSize, coerceFunc, allowLoose) {\n    _classCallCheck(this, Reader);\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n  _createClass(Reader, [{\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return this._offset;\n    }\n    // The default Coerce function\n  }, {\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      if (this._coerceFunc) {\n        return this._coerceFunc(name, value);\n      }\n      return Reader.coerce(name, value);\n    }\n  }, {\n    key: \"_peekBytes\",\n    value: function _peekBytes(offset, length, loose) {\n      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n      if (this._offset + alignedLength > this._data.length) {\n        if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n          alignedLength = length;\n        } else {\n          logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n            length: this._data.length,\n            offset: this._offset + alignedLength\n          });\n        }\n      }\n      return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n  }, {\n    key: \"subReader\",\n    value: function subReader(offset) {\n      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length, loose) {\n      var bytes = this._peekBytes(0, length, !!loose);\n      this._offset += bytes.length;\n      // @TODO: Make sure the length..end bytes are all 0?\n      return bytes.slice(0, length);\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return BigNumber.from(this.readBytes(this.wordSize));\n    }\n  }], [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      var match = name.match(\"^u?int([0-9]+)$\");\n      if (match && parseInt(match[1]) <= 48) {\n        value = value.toNumber();\n      }\n      return value;\n    }\n  }]);\n  return Reader;\n}();","map":{"version":3,"names":["_classCallCheck","_createClass","arrayify","concat","hexConcat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","name","type","localName","dynamic","value","_throwError","message","throwArgumentError","Writer","wordSize","_data","_dataLength","_padding","Uint8Array","get","_writeData","data","length","appendWriter","writer","writeBytes","bytes","paddingOffset","_getValue","from","throwError","BUFFER_OVERRUN","offset","writeValue","writeUpdatableValue","_this","Reader","coerceFunc","allowLoose","_offset","coerce","_coerceFunc","_peekBytes","loose","alignedLength","Math","ceil","subReader","readBytes","readValue","match","parseInt","toNumber"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\ethers\\node_modules\\@ethersproject\\abi\\src.ts\\coders\\abstract-coder.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}