{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nvar _constructorGuard = {};\nvar Zero = BigNumber.from(0);\nvar NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n  var params = {\n    fault: fault,\n    operation: operation\n  };\n  if (value !== undefined) {\n    params.value = value;\n  }\n  return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nvar zeros = \"0\";\nwhile (zeros.length < 256) {\n  zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n  var multiplier = getMultiplier(decimals);\n  // Make sure wei is a big number (convert as necessary)\n  value = BigNumber.from(value);\n  var negative = value.lt(Zero);\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n  var fraction = value.mod(multiplier).toString();\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  }\n  // Strip training 0\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  var whole = value.div(multiplier).toString();\n  if (multiplier.length === 1) {\n    value = whole;\n  } else {\n    value = whole + \".\" + fraction;\n  }\n  if (negative) {\n    value = \"-\" + value;\n  }\n  return value;\n}\nexport function parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n  var multiplier = getMultiplier(decimals);\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  }\n  // Is it negative?\n  var negative = value.substring(0, 1) === \"-\";\n  if (negative) {\n    value = value.substring(1);\n  }\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  }\n  // Split it into a whole and fractional part\n  var comps = value.split(\".\");\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n  var whole = comps[0],\n    fraction = comps[1];\n  if (!whole) {\n    whole = \"0\";\n  }\n  if (!fraction) {\n    fraction = \"0\";\n  }\n  // Get significant digits to check truncation for underflow\n  {\n    var sigFraction = fraction.replace(/^([0-9]*?)(0*)$/, function (all, sig, zeros) {\n      return sig;\n    });\n    if (sigFraction.length > multiplier.length - 1) {\n      throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n  }\n  // Fully pad the string with zeros to get to wei\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n  var wholeValue = BigNumber.from(whole);\n  var fractionValue = BigNumber.from(fraction);\n  var wei = wholeValue.mul(multiplier).add(fractionValue);\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n  return wei;\n}\nexport var FixedFormat = /*#__PURE__*/function () {\n  function FixedFormat(constructorGuard, signed, width, decimals) {\n    _classCallCheck(this, FixedFormat);\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n  _createClass(FixedFormat, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (value instanceof FixedFormat) {\n        return value;\n      }\n      if (typeof value === \"number\") {\n        value = \"fixed128x\".concat(value);\n      }\n      var signed = true;\n      var width = 128;\n      var decimals = 18;\n      if (typeof value === \"string\") {\n        if (value === \"fixed\") {\n          // defaults...\n        } else if (value === \"ufixed\") {\n          signed = false;\n        } else {\n          var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n          if (!match) {\n            logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n          }\n          signed = match[1] !== \"u\";\n          width = parseInt(match[2]);\n          decimals = parseInt(match[3]);\n        }\n      } else if (value) {\n        var check = function check(key, type, defaultValue) {\n          if (value[key] == null) {\n            return defaultValue;\n          }\n          if (typeof value[key] !== type) {\n            logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n          }\n          return value[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n      }\n      if (width % 8) {\n        logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n      }\n      if (decimals > 80) {\n        logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n      }\n      return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n  }]);\n  return FixedFormat;\n}();\nexport var FixedNumber = /*#__PURE__*/function () {\n  function FixedNumber(constructorGuard, hex, value, format) {\n    _classCallCheck(this, FixedNumber);\n    logger.checkNew(this instanceof FixedNumber ? this.constructor : void 0, FixedNumber);\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n  _createClass(FixedNumber, [{\n    key: \"_checkFormat\",\n    value: function _checkFormat(other) {\n      if (this.format.name !== other.format.name) {\n        logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n      }\n    }\n  }, {\n    key: \"addUnsafe\",\n    value: function addUnsafe(other) {\n      this._checkFormat(other);\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"subUnsafe\",\n    value: function subUnsafe(other) {\n      this._checkFormat(other);\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"mulUnsafe\",\n    value: function mulUnsafe(other) {\n      this._checkFormat(other);\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"divUnsafe\",\n    value: function divUnsafe(other) {\n      this._checkFormat(other);\n      var a = parseFixed(this._value, this.format.decimals);\n      var b = parseFixed(other._value, other.format.decimals);\n      return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n  }, {\n    key: \"floor\",\n    value: function floor() {\n      var comps = this.toString().split(\".\");\n      if (comps.length === 1) {\n        comps.push(\"0\");\n      }\n      var result = FixedNumber.from(comps[0], this.format);\n      var hasFraction = !comps[1].match(/^(0*)$/);\n      if (this.isNegative() && hasFraction) {\n        result = result.subUnsafe(ONE);\n      }\n      return result;\n    }\n  }, {\n    key: \"ceiling\",\n    value: function ceiling() {\n      var comps = this.toString().split(\".\");\n      if (comps.length === 1) {\n        comps.push(\"0\");\n      }\n      var result = FixedNumber.from(comps[0], this.format);\n      var hasFraction = !comps[1].match(/^(0*)$/);\n      if (!this.isNegative() && hasFraction) {\n        result = result.addUnsafe(ONE);\n      }\n      return result;\n    }\n    // @TODO: Support other rounding algorithms\n  }, {\n    key: \"round\",\n    value: function round(decimals) {\n      if (decimals == null) {\n        decimals = 0;\n      }\n      // If we are already in range, we're done\n      var comps = this.toString().split(\".\");\n      if (comps.length === 1) {\n        comps.push(\"0\");\n      }\n      if (decimals < 0 || decimals > 80 || decimals % 1) {\n        logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n      }\n      if (comps[1].length <= decimals) {\n        return this;\n      }\n      var factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n      var bump = BUMP.toFormat(this.format);\n      return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this._value === \"0.0\" || this._value === \"0\";\n    }\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return this._value[0] === \"-\";\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._value;\n    }\n  }, {\n    key: \"toHexString\",\n    value: function toHexString(width) {\n      if (width == null) {\n        return this._hex;\n      }\n      if (width % 8) {\n        logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n      }\n      var hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n      return hexZeroPad(hex, width / 8);\n    }\n  }, {\n    key: \"toUnsafeFloat\",\n    value: function toUnsafeFloat() {\n      return parseFloat(this.toString());\n    }\n  }, {\n    key: \"toFormat\",\n    value: function toFormat(format) {\n      return FixedNumber.fromString(this._value, format);\n    }\n  }], [{\n    key: \"fromValue\",\n    value: function fromValue(value, decimals, format) {\n      // If decimals looks more like a format, and there is no format, shift the parameters\n      if (format == null && decimals != null && !isBigNumberish(decimals)) {\n        format = decimals;\n        decimals = null;\n      }\n      if (decimals == null) {\n        decimals = 0;\n      }\n      if (format == null) {\n        format = \"fixed\";\n      }\n      return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, format) {\n      if (format == null) {\n        format = \"fixed\";\n      }\n      var fixedFormat = FixedFormat.from(format);\n      var numeric = parseFixed(value, fixedFormat.decimals);\n      if (!fixedFormat.signed && numeric.lt(Zero)) {\n        throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n      }\n      var hex = null;\n      if (fixedFormat.signed) {\n        hex = numeric.toTwos(fixedFormat.width).toHexString();\n      } else {\n        hex = numeric.toHexString();\n        hex = hexZeroPad(hex, fixedFormat.width / 8);\n      }\n      var decimal = formatFixed(numeric, fixedFormat.decimals);\n      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(value, format) {\n      if (format == null) {\n        format = \"fixed\";\n      }\n      var fixedFormat = FixedFormat.from(format);\n      if (arrayify(value).length > fixedFormat.width / 8) {\n        throw new Error(\"overflow\");\n      }\n      var numeric = BigNumber.from(value);\n      if (fixedFormat.signed) {\n        numeric = numeric.fromTwos(fixedFormat.width);\n      }\n      var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n      var decimal = formatFixed(numeric, fixedFormat.decimals);\n      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n  }, {\n    key: \"from\",\n    value: function from(value, format) {\n      if (typeof value === \"string\") {\n        return FixedNumber.fromString(value, format);\n      }\n      if (isBytes(value)) {\n        return FixedNumber.fromBytes(value, format);\n      }\n      try {\n        return FixedNumber.fromValue(value, 0, format);\n      } catch (error) {\n        // Allow NUMERIC_FAULT to bubble up\n        if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n          throw error;\n        }\n      }\n      return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n  }, {\n    key: \"isFixedNumber\",\n    value: function isFixedNumber(value) {\n      return !!(value && value._isFixedNumber);\n    }\n  }]);\n  return FixedNumber;\n}();\nvar ONE = FixedNumber.from(1);\nvar BUMP = FixedNumber.from(\"0.5\");","map":{"version":3,"names":["_classCallCheck","_createClass","arrayify","hexZeroPad","isBytes","Logger","version","logger","BigNumber","isBigNumberish","_constructorGuard","Zero","from","NegativeOne","throwFault","message","fault","operation","value","params","undefined","throwError","errors","NUMERIC_FAULT","zeros","length","getMultiplier","decimals","toNumber","e","substring","throwArgumentError","formatFixed","multiplier","negative","lt","mul","fraction","mod","toString","match","whole","div","parseFixed","comps","split","sigFraction","replace","all","sig","wholeValue","fractionValue","wei","add","FixedFormat","constructorGuard","signed","width","UNSUPPORTED_OPERATION","name","String","_multiplier","Object","freeze","key","concat","parseInt","check","type","defaultValue","FixedNumber","hex","format","checkNew","constructor","_hex","_value","_isFixedNumber","_checkFormat","other","addUnsafe","a","b","fromValue","subUnsafe","sub","mulUnsafe","divUnsafe","floor","push","result","hasFraction","isNegative","ONE","ceiling","round","factor","bump","BUMP","toFormat","isZero","toHexString","fromTwos","toTwos","toUnsafeFloat","parseFloat","fromString","fixedFormat","numeric","decimal","fromBytes","Error","error","code","INVALID_ARGUMENT","isFixedNumber"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\ethers\\node_modules\\@ethersproject\\bignumber\\src.ts\\fixednumber.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Get significant digits to check truncation for underflow\n    {\n    const sigFraction = fraction.replace(/^([0-9]*?)(0*)$/, (all, sig, zeros) => (sig));\n        if (sigFraction.length > multiplier.length - 1) {\n            throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n        }\n    }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        logger.checkNew(new.target, FixedNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE);\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE);\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,eAAA;AAAA,OAAAC,YAAA;AAEb,SAASC,QAAQ,EAAaC,UAAU,EAAEC,OAAO,QAAQ,sBAAsB;AAE/E,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,OAAO,QAAQ,YAAY;AACpC,IAAMC,MAAM,GAAG,IAAIF,MAAM,CAACC,OAAO,CAAC;AAElC,SAASE,SAAS,EAAgBC,cAAc,QAAQ,aAAa;AAErE,IAAMC,iBAAiB,GAAG,EAAG;AAE7B,IAAMC,IAAI,GAAGH,SAAS,CAACI,IAAI,CAAC,CAAC,CAAC;AAC9B,IAAMC,WAAW,GAAGL,SAAS,CAACI,IAAI,CAAC,CAAC,CAAC,CAAC;AAEtC,SAASE,UAAUA,CAACC,OAAe,EAAEC,KAAa,EAAEC,SAAiB,EAAEC,KAAW;EAC9E,IAAMC,MAAM,GAAQ;IAAEH,KAAK,EAAEA,KAAK;IAAEC,SAAS,EAAEA;EAAS,CAAE;EAC1D,IAAIC,KAAK,KAAKE,SAAS,EAAE;IAAED,MAAM,CAACD,KAAK,GAAGA,KAAK;;EAC/C,OAAOX,MAAM,CAACc,UAAU,CAACN,OAAO,EAAEV,MAAM,CAACiB,MAAM,CAACC,aAAa,EAAEJ,MAAM,CAAC;AAC1E;AAEA;AACA,IAAIK,KAAK,GAAG,GAAG;AACf,OAAOA,KAAK,CAACC,MAAM,GAAG,GAAG,EAAE;EAAED,KAAK,IAAIA,KAAK;;AAE3C;AACA,SAASE,aAAaA,CAACC,QAAsB;EAEzC,IAAI,OAAOA,QAAS,KAAK,QAAQ,EAAE;IAC/B,IAAI;MACAA,QAAQ,GAAGnB,SAAS,CAACI,IAAI,CAACe,QAAQ,CAAC,CAACC,QAAQ,EAAE;KACjD,CAAC,OAAOC,CAAC,EAAE;;EAGhB,IAAI,OAAOF,QAAS,KAAK,QAAQ,IAAIA,QAAQ,IAAI,CAAC,IAAIA,QAAQ,IAAI,GAAG,IAAI,EAAEA,QAAQ,GAAG,CAAC,CAAC,EAAE;IACtF,OAAQ,GAAG,GAAGH,KAAK,CAACM,SAAS,CAAC,CAAC,EAAEH,QAAQ,CAAC;;EAG9C,OAAOpB,MAAM,CAACwB,kBAAkB,CAAC,sBAAsB,EAAE,UAAU,EAAEJ,QAAQ,CAAC;AAClF;AAEA,OAAM,SAAUK,WAAWA,CAACd,KAAmB,EAAES,QAAgC;EAC7E,IAAIA,QAAQ,IAAI,IAAI,EAAE;IAAEA,QAAQ,GAAG,CAAC;;EACpC,IAAMM,UAAU,GAAGP,aAAa,CAACC,QAAQ,CAAC;EAE1C;EACAT,KAAK,GAAGV,SAAS,CAACI,IAAI,CAACM,KAAK,CAAC;EAE7B,IAAMgB,QAAQ,GAAGhB,KAAK,CAACiB,EAAE,CAACxB,IAAI,CAAC;EAC/B,IAAIuB,QAAQ,EAAE;IAAEhB,KAAK,GAAGA,KAAK,CAACkB,GAAG,CAACvB,WAAW,CAAC;;EAE9C,IAAIwB,QAAQ,GAAGnB,KAAK,CAACoB,GAAG,CAACL,UAAU,CAAC,CAACM,QAAQ,EAAE;EAC/C,OAAOF,QAAQ,CAACZ,MAAM,GAAGQ,UAAU,CAACR,MAAM,GAAG,CAAC,EAAE;IAAEY,QAAQ,GAAG,GAAG,GAAGA,QAAQ;;EAE3E;EACAA,QAAQ,GAAGA,QAAQ,CAACG,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;EAEpD,IAAMC,KAAK,GAAGvB,KAAK,CAACwB,GAAG,CAACT,UAAU,CAAC,CAACM,QAAQ,EAAE;EAC9C,IAAIN,UAAU,CAACR,MAAM,KAAK,CAAC,EAAE;IACzBP,KAAK,GAAGuB,KAAK;GAChB,MAAM;IACHvB,KAAK,GAAGuB,KAAK,GAAG,GAAG,GAAGJ,QAAQ;;EAGlC,IAAIH,QAAQ,EAAE;IAAEhB,KAAK,GAAG,GAAG,GAAGA,KAAK;;EAEnC,OAAOA,KAAK;AAChB;AAEA,OAAM,SAAUyB,UAAUA,CAACzB,KAAa,EAAES,QAAuB;EAC7D,IAAIA,QAAQ,IAAI,IAAI,EAAE;IAAEA,QAAQ,GAAG,CAAC;;EACpC,IAAMM,UAAU,GAAGP,aAAa,CAACC,QAAQ,CAAC;EAE1C,IAAI,OAAOT,KAAM,KAAK,QAAQ,IAAI,CAACA,KAAK,CAACsB,KAAK,CAAC,cAAc,CAAC,EAAE;IAC5DjC,MAAM,CAACwB,kBAAkB,CAAC,uBAAuB,EAAE,OAAO,EAAEb,KAAK,CAAC;;EAGtE;EACA,IAAMgB,QAAQ,GAAIhB,KAAK,CAACY,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAI;EAChD,IAAII,QAAQ,EAAE;IAAEhB,KAAK,GAAGA,KAAK,CAACY,SAAS,CAAC,CAAC,CAAC;;EAE1C,IAAIZ,KAAK,KAAK,GAAG,EAAE;IACfX,MAAM,CAACwB,kBAAkB,CAAC,eAAe,EAAE,OAAO,EAAEb,KAAK,CAAC;;EAG9D;EACA,IAAM0B,KAAK,GAAG1B,KAAK,CAAC2B,KAAK,CAAC,GAAG,CAAC;EAC9B,IAAID,KAAK,CAACnB,MAAM,GAAG,CAAC,EAAE;IAClBlB,MAAM,CAACwB,kBAAkB,CAAC,yBAAyB,EAAE,OAAO,EAAEb,KAAK,CAAC;;EAGxE,IAAIuB,KAAK,GAAGG,KAAK,CAAC,CAAC,CAAC;IAAEP,QAAQ,GAAGO,KAAK,CAAC,CAAC,CAAC;EACzC,IAAI,CAACH,KAAK,EAAE;IAAEA,KAAK,GAAG,GAAG;;EACzB,IAAI,CAACJ,QAAQ,EAAE;IAAEA,QAAQ,GAAG,GAAG;;EAE/B;EACA;IACA,IAAMS,WAAW,GAAGT,QAAQ,CAACU,OAAO,CAAC,iBAAiB,EAAE,UAACC,GAAG,EAAEC,GAAG,EAAEzB,KAAK;MAAA,OAAMyB,GAAG;IAAA,CAAC,CAAC;IAC/E,IAAIH,WAAW,CAACrB,MAAM,GAAGQ,UAAU,CAACR,MAAM,GAAG,CAAC,EAAE;MAC5CX,UAAU,CAAC,uCAAuC,EAAE,WAAW,EAAE,YAAY,CAAC;;;EAItF;EACA,OAAOuB,QAAQ,CAACZ,MAAM,GAAGQ,UAAU,CAACR,MAAM,GAAG,CAAC,EAAE;IAAEY,QAAQ,IAAI,GAAG;;EAEjE,IAAMa,UAAU,GAAG1C,SAAS,CAACI,IAAI,CAAC6B,KAAK,CAAC;EACxC,IAAMU,aAAa,GAAG3C,SAAS,CAACI,IAAI,CAACyB,QAAQ,CAAC;EAE9C,IAAIe,GAAG,GAAIF,UAAU,CAACd,GAAG,CAACH,UAAU,CAAC,CAAEoB,GAAG,CAACF,aAAa,CAAC;EAEzD,IAAIjB,QAAQ,EAAE;IAAEkB,GAAG,GAAGA,GAAG,CAAChB,GAAG,CAACvB,WAAW,CAAC;;EAE1C,OAAOuC,GAAG;AACd;AAEA,WAAaE,WAAW;EAOpB,SAAAA,YAAYC,gBAAqB,EAAEC,MAAe,EAAEC,KAAa,EAAE9B,QAAgB;IAAA3B,eAAA,OAAAsD,WAAA;IAC/E,IAAIC,gBAAgB,KAAK7C,iBAAiB,EAAE;MACxCH,MAAM,CAACc,UAAU,CAAC,0DAA0D,EAAEhB,MAAM,CAACiB,MAAM,CAACoC,qBAAqB,EAAE;QAC/GzC,SAAS,EAAE;OACd,CAAC;;IAGN,IAAI,CAACuC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC9B,QAAQ,GAAGA,QAAQ;IAExB,IAAI,CAACgC,IAAI,GAAG,CAACH,MAAM,GAAG,EAAE,GAAE,GAAG,IAAI,OAAO,GAAGI,MAAM,CAACH,KAAK,CAAC,GAAG,GAAG,GAAGG,MAAM,CAACjC,QAAQ,CAAC;IAEjF,IAAI,CAACkC,WAAW,GAAGnC,aAAa,CAACC,QAAQ,CAAC;IAE1CmC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EACvB;EAAC9D,YAAA,CAAAqD,WAAA;IAAAU,GAAA;IAAA9C,KAAA,EAED,SAAAN,KAAYM,KAAU;MAClB,IAAIA,KAAK,YAAYoC,WAAW,EAAE;QAAE,OAAOpC,KAAK;;MAEhD,IAAI,OAAOA,KAAM,KAAK,QAAQ,EAAE;QAC5BA,KAAK,eAAA+C,MAAA,CAAe/C,KAAK,CAAE;;MAG/B,IAAIsC,MAAM,GAAG,IAAI;MACjB,IAAIC,KAAK,GAAG,GAAG;MACf,IAAI9B,QAAQ,GAAG,EAAE;MAEjB,IAAI,OAAOT,KAAM,KAAK,QAAQ,EAAE;QAC5B,IAAIA,KAAK,KAAK,OAAO,EAAE;UACnB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,QAAQ,EAAE;UAC3BsC,MAAM,GAAG,KAAK;SACjB,MAAM;UACH,IAAMhB,KAAK,GAAGtB,KAAK,CAACsB,KAAK,CAAC,8BAA8B,CAAC;UACzD,IAAI,CAACA,KAAK,EAAE;YAAEjC,MAAM,CAACwB,kBAAkB,CAAC,sBAAsB,EAAE,QAAQ,EAAEb,KAAK,CAAC;;UAChFsC,MAAM,GAAIhB,KAAK,CAAC,CAAC,CAAC,KAAK,GAAI;UAC3BiB,KAAK,GAAGS,QAAQ,CAAC1B,KAAK,CAAC,CAAC,CAAC,CAAC;UAC1Bb,QAAQ,GAAGuC,QAAQ,CAAC1B,KAAK,CAAC,CAAC,CAAC,CAAC;;OAEpC,MAAM,IAAItB,KAAK,EAAE;QACd,IAAMiD,KAAK,GAAG,SAARA,KAAKA,CAAIH,GAAW,EAAEI,IAAY,EAAEC,YAAiB,EAAS;UAChE,IAAInD,KAAK,CAAC8C,GAAG,CAAC,IAAI,IAAI,EAAE;YAAE,OAAOK,YAAY;;UAC7C,IAAI,OAAOnD,KAAK,CAAC8C,GAAG,CAAE,KAAKI,IAAI,EAAE;YAC7B7D,MAAM,CAACwB,kBAAkB,CAAC,wBAAwB,GAAGiC,GAAG,GAAG,OAAO,GAAGI,IAAI,GAAE,GAAG,EAAE,SAAS,GAAGJ,GAAG,EAAE9C,KAAK,CAAC8C,GAAG,CAAC,CAAC;;UAEhH,OAAO9C,KAAK,CAAC8C,GAAG,CAAC;QACrB,CAAC;QACDR,MAAM,GAAGW,KAAK,CAAC,QAAQ,EAAE,SAAS,EAAEX,MAAM,CAAC;QAC3CC,KAAK,GAAGU,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAEV,KAAK,CAAC;QACvC9B,QAAQ,GAAGwC,KAAK,CAAC,UAAU,EAAE,QAAQ,EAAExC,QAAQ,CAAC;;MAGpD,IAAI8B,KAAK,GAAG,CAAC,EAAE;QACXlD,MAAM,CAACwB,kBAAkB,CAAC,+CAA+C,EAAE,cAAc,EAAE0B,KAAK,CAAC;;MAGrG,IAAI9B,QAAQ,GAAG,EAAE,EAAE;QACfpB,MAAM,CAACwB,kBAAkB,CAAC,2CAA2C,EAAE,iBAAiB,EAAEJ,QAAQ,CAAC;;MAGvG,OAAO,IAAI2B,WAAW,CAAC5C,iBAAiB,EAAE8C,MAAM,EAAEC,KAAK,EAAE9B,QAAQ,CAAC;IACtE;EAAC;EAAA,OAAA2B,WAAA;AAAA;AAGL,WAAagB,WAAW;EAOpB,SAAAA,YAAYf,gBAAqB,EAAEgB,GAAW,EAAErD,KAAa,EAAEsD,MAAoB;IAAAxE,eAAA,OAAAsE,WAAA;IAC/E/D,MAAM,CAACkE,QAAQ,iBAAAH,WAAA,QAAAI,WAAA,WAAaJ,WAAW,CAAC;IAExC,IAAIf,gBAAgB,KAAK7C,iBAAiB,EAAE;MACxCH,MAAM,CAACc,UAAU,CAAC,0DAA0D,EAAEhB,MAAM,CAACiB,MAAM,CAACoC,qBAAqB,EAAE;QAC/GzC,SAAS,EAAE;OACd,CAAC;;IAGN,IAAI,CAACuD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACG,IAAI,GAAGJ,GAAG;IACf,IAAI,CAACK,MAAM,GAAG1D,KAAK;IAEnB,IAAI,CAAC2D,cAAc,GAAG,IAAI;IAE1Bf,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EACvB;EAAC9D,YAAA,CAAAqE,WAAA;IAAAN,GAAA;IAAA9C,KAAA,EAED,SAAA4D,aAAaC,KAAkB;MAC3B,IAAI,IAAI,CAACP,MAAM,CAACb,IAAI,KAAKoB,KAAK,CAACP,MAAM,CAACb,IAAI,EAAE;QACxCpD,MAAM,CAACwB,kBAAkB,CAAC,+CAA+C,EAAE,OAAO,EAAEgD,KAAK,CAAC;;IAElG;EAAC;IAAAf,GAAA;IAAA9C,KAAA,EAED,SAAA8D,UAAUD,KAAkB;MACxB,IAAI,CAACD,YAAY,CAACC,KAAK,CAAC;MACxB,IAAME,CAAC,GAAGtC,UAAU,CAAC,IAAI,CAACiC,MAAM,EAAE,IAAI,CAACJ,MAAM,CAAC7C,QAAQ,CAAC;MACvD,IAAMuD,CAAC,GAAGvC,UAAU,CAACoC,KAAK,CAACH,MAAM,EAAEG,KAAK,CAACP,MAAM,CAAC7C,QAAQ,CAAC;MACzD,OAAO2C,WAAW,CAACa,SAAS,CAACF,CAAC,CAAC5B,GAAG,CAAC6B,CAAC,CAAC,EAAE,IAAI,CAACV,MAAM,CAAC7C,QAAQ,EAAE,IAAI,CAAC6C,MAAM,CAAC;IAC7E;EAAC;IAAAR,GAAA;IAAA9C,KAAA,EAED,SAAAkE,UAAUL,KAAkB;MACxB,IAAI,CAACD,YAAY,CAACC,KAAK,CAAC;MACxB,IAAME,CAAC,GAAGtC,UAAU,CAAC,IAAI,CAACiC,MAAM,EAAE,IAAI,CAACJ,MAAM,CAAC7C,QAAQ,CAAC;MACvD,IAAMuD,CAAC,GAAGvC,UAAU,CAACoC,KAAK,CAACH,MAAM,EAAEG,KAAK,CAACP,MAAM,CAAC7C,QAAQ,CAAC;MACzD,OAAO2C,WAAW,CAACa,SAAS,CAACF,CAAC,CAACI,GAAG,CAACH,CAAC,CAAC,EAAE,IAAI,CAACV,MAAM,CAAC7C,QAAQ,EAAE,IAAI,CAAC6C,MAAM,CAAC;IAC7E;EAAC;IAAAR,GAAA;IAAA9C,KAAA,EAED,SAAAoE,UAAUP,KAAkB;MACxB,IAAI,CAACD,YAAY,CAACC,KAAK,CAAC;MACxB,IAAME,CAAC,GAAGtC,UAAU,CAAC,IAAI,CAACiC,MAAM,EAAE,IAAI,CAACJ,MAAM,CAAC7C,QAAQ,CAAC;MACvD,IAAMuD,CAAC,GAAGvC,UAAU,CAACoC,KAAK,CAACH,MAAM,EAAEG,KAAK,CAACP,MAAM,CAAC7C,QAAQ,CAAC;MACzD,OAAO2C,WAAW,CAACa,SAAS,CAACF,CAAC,CAAC7C,GAAG,CAAC8C,CAAC,CAAC,CAACxC,GAAG,CAAC,IAAI,CAAC8B,MAAM,CAACX,WAAW,CAAC,EAAE,IAAI,CAACW,MAAM,CAAC7C,QAAQ,EAAE,IAAI,CAAC6C,MAAM,CAAC;IAC1G;EAAC;IAAAR,GAAA;IAAA9C,KAAA,EAED,SAAAqE,UAAUR,KAAkB;MACxB,IAAI,CAACD,YAAY,CAACC,KAAK,CAAC;MACxB,IAAME,CAAC,GAAGtC,UAAU,CAAC,IAAI,CAACiC,MAAM,EAAE,IAAI,CAACJ,MAAM,CAAC7C,QAAQ,CAAC;MACvD,IAAMuD,CAAC,GAAGvC,UAAU,CAACoC,KAAK,CAACH,MAAM,EAAEG,KAAK,CAACP,MAAM,CAAC7C,QAAQ,CAAC;MACzD,OAAO2C,WAAW,CAACa,SAAS,CAACF,CAAC,CAAC7C,GAAG,CAAC,IAAI,CAACoC,MAAM,CAACX,WAAW,CAAC,CAACnB,GAAG,CAACwC,CAAC,CAAC,EAAE,IAAI,CAACV,MAAM,CAAC7C,QAAQ,EAAE,IAAI,CAAC6C,MAAM,CAAC;IAC1G;EAAC;IAAAR,GAAA;IAAA9C,KAAA,EAED,SAAAsE,MAAA,EAAK;MACD,IAAM5C,KAAK,GAAG,IAAI,CAACL,QAAQ,EAAE,CAACM,KAAK,CAAC,GAAG,CAAC;MACxC,IAAID,KAAK,CAACnB,MAAM,KAAK,CAAC,EAAE;QAAEmB,KAAK,CAAC6C,IAAI,CAAC,GAAG,CAAC;;MAEzC,IAAIC,MAAM,GAAGpB,WAAW,CAAC1D,IAAI,CAACgC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC4B,MAAM,CAAC;MAEpD,IAAMmB,WAAW,GAAG,CAAC/C,KAAK,CAAC,CAAC,CAAC,CAACJ,KAAK,CAAC,QAAQ,CAAC;MAC7C,IAAI,IAAI,CAACoD,UAAU,EAAE,IAAID,WAAW,EAAE;QAClCD,MAAM,GAAGA,MAAM,CAACN,SAAS,CAACS,GAAG,CAAC;;MAGlC,OAAOH,MAAM;IACjB;EAAC;IAAA1B,GAAA;IAAA9C,KAAA,EAED,SAAA4E,QAAA,EAAO;MACH,IAAMlD,KAAK,GAAG,IAAI,CAACL,QAAQ,EAAE,CAACM,KAAK,CAAC,GAAG,CAAC;MACxC,IAAID,KAAK,CAACnB,MAAM,KAAK,CAAC,EAAE;QAAEmB,KAAK,CAAC6C,IAAI,CAAC,GAAG,CAAC;;MAEzC,IAAIC,MAAM,GAAGpB,WAAW,CAAC1D,IAAI,CAACgC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC4B,MAAM,CAAC;MAEpD,IAAMmB,WAAW,GAAG,CAAC/C,KAAK,CAAC,CAAC,CAAC,CAACJ,KAAK,CAAC,QAAQ,CAAC;MAC7C,IAAI,CAAC,IAAI,CAACoD,UAAU,EAAE,IAAID,WAAW,EAAE;QACnCD,MAAM,GAAGA,MAAM,CAACV,SAAS,CAACa,GAAG,CAAC;;MAGlC,OAAOH,MAAM;IACjB;IAEA;EAAA;IAAA1B,GAAA;IAAA9C,KAAA,EACA,SAAA6E,MAAMpE,QAAiB;MACnB,IAAIA,QAAQ,IAAI,IAAI,EAAE;QAAEA,QAAQ,GAAG,CAAC;;MAEpC;MACA,IAAMiB,KAAK,GAAG,IAAI,CAACL,QAAQ,EAAE,CAACM,KAAK,CAAC,GAAG,CAAC;MACxC,IAAID,KAAK,CAACnB,MAAM,KAAK,CAAC,EAAE;QAAEmB,KAAK,CAAC6C,IAAI,CAAC,GAAG,CAAC;;MAEzC,IAAI9D,QAAQ,GAAG,CAAC,IAAIA,QAAQ,GAAG,EAAE,IAAKA,QAAQ,GAAG,CAAE,EAAE;QACjDpB,MAAM,CAACwB,kBAAkB,CAAC,uBAAuB,EAAE,UAAU,EAAEJ,QAAQ,CAAC;;MAG5E,IAAIiB,KAAK,CAAC,CAAC,CAAC,CAACnB,MAAM,IAAIE,QAAQ,EAAE;QAAE,OAAO,IAAI;;MAE9C,IAAMqE,MAAM,GAAG1B,WAAW,CAAC1D,IAAI,CAAC,GAAG,GAAGY,KAAK,CAACM,SAAS,CAAC,CAAC,EAAEH,QAAQ,CAAC,EAAE,IAAI,CAAC6C,MAAM,CAAC;MAChF,IAAMyB,IAAI,GAAGC,IAAI,CAACC,QAAQ,CAAC,IAAI,CAAC3B,MAAM,CAAC;MAEvC,OAAO,IAAI,CAACc,SAAS,CAACU,MAAM,CAAC,CAAChB,SAAS,CAACiB,IAAI,CAAC,CAACT,KAAK,EAAE,CAACD,SAAS,CAACS,MAAM,CAAC;IAC3E;EAAC;IAAAhC,GAAA;IAAA9C,KAAA,EAED,SAAAkF,OAAA,EAAM;MACF,OAAQ,IAAI,CAACxB,MAAM,KAAK,KAAK,IAAI,IAAI,CAACA,MAAM,KAAK,GAAG;IACxD;EAAC;IAAAZ,GAAA;IAAA9C,KAAA,EAED,SAAA0E,WAAA,EAAU;MACN,OAAQ,IAAI,CAAChB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG;IAClC;EAAC;IAAAZ,GAAA;IAAA9C,KAAA,EAED,SAAAqB,SAAA,EAAQ;MAAa,OAAO,IAAI,CAACqC,MAAM;IAAE;EAAC;IAAAZ,GAAA;IAAA9C,KAAA,EAE1C,SAAAmF,YAAY5C,KAAc;MACtB,IAAIA,KAAK,IAAI,IAAI,EAAE;QAAE,OAAO,IAAI,CAACkB,IAAI;;MACrC,IAAIlB,KAAK,GAAG,CAAC,EAAE;QAAElD,MAAM,CAACwB,kBAAkB,CAAC,oBAAoB,EAAE,OAAO,EAAE0B,KAAK,CAAC;;MAChF,IAAMc,GAAG,GAAG/D,SAAS,CAACI,IAAI,CAAC,IAAI,CAAC+D,IAAI,CAAC,CAAC2B,QAAQ,CAAC,IAAI,CAAC9B,MAAM,CAACf,KAAK,CAAC,CAAC8C,MAAM,CAAC9C,KAAK,CAAC,CAAC4C,WAAW,EAAE;MAC7F,OAAOlG,UAAU,CAACoE,GAAG,EAAEd,KAAK,GAAG,CAAC,CAAC;IACrC;EAAC;IAAAO,GAAA;IAAA9C,KAAA,EAED,SAAAsF,cAAA,EAAa;MAAa,OAAOC,UAAU,CAAC,IAAI,CAAClE,QAAQ,EAAE,CAAC;IAAE;EAAC;IAAAyB,GAAA;IAAA9C,KAAA,EAE/D,SAAAiF,SAAS3B,MAA4B;MACjC,OAAOF,WAAW,CAACoC,UAAU,CAAC,IAAI,CAAC9B,MAAM,EAAEJ,MAAM,CAAC;IACtD;EAAC;IAAAR,GAAA;IAAA9C,KAAA,EAGD,SAAAiE,UAAiBjE,KAAgB,EAAES,QAAuB,EAAE6C,MAAsC;MAC9F;MACA,IAAIA,MAAM,IAAI,IAAI,IAAI7C,QAAQ,IAAI,IAAI,IAAI,CAAClB,cAAc,CAACkB,QAAQ,CAAC,EAAE;QACjE6C,MAAM,GAAG7C,QAAQ;QACjBA,QAAQ,GAAG,IAAI;;MAGnB,IAAIA,QAAQ,IAAI,IAAI,EAAE;QAAEA,QAAQ,GAAG,CAAC;;MACpC,IAAI6C,MAAM,IAAI,IAAI,EAAE;QAAEA,MAAM,GAAG,OAAO;;MAEtC,OAAOF,WAAW,CAACoC,UAAU,CAAC1E,WAAW,CAACd,KAAK,EAAES,QAAQ,CAAC,EAAE2B,WAAW,CAAC1C,IAAI,CAAC4D,MAAM,CAAC,CAAC;IACzF;EAAC;IAAAR,GAAA;IAAA9C,KAAA,EAGD,SAAAwF,WAAkBxF,KAAa,EAAEsD,MAAsC;MACnE,IAAIA,MAAM,IAAI,IAAI,EAAE;QAAEA,MAAM,GAAG,OAAO;;MAEtC,IAAMmC,WAAW,GAAGrD,WAAW,CAAC1C,IAAI,CAAC4D,MAAM,CAAC;MAE5C,IAAMoC,OAAO,GAAGjE,UAAU,CAACzB,KAAK,EAAEyF,WAAW,CAAChF,QAAQ,CAAC;MAEvD,IAAI,CAACgF,WAAW,CAACnD,MAAM,IAAIoD,OAAO,CAACzE,EAAE,CAACxB,IAAI,CAAC,EAAE;QACzCG,UAAU,CAAC,mCAAmC,EAAE,UAAU,EAAE,OAAO,EAAEI,KAAK,CAAC;;MAG/E,IAAIqD,GAAG,GAAW,IAAI;MACtB,IAAIoC,WAAW,CAACnD,MAAM,EAAE;QACpBe,GAAG,GAAGqC,OAAO,CAACL,MAAM,CAACI,WAAW,CAAClD,KAAK,CAAC,CAAC4C,WAAW,EAAE;OACxD,MAAM;QACH9B,GAAG,GAAGqC,OAAO,CAACP,WAAW,EAAE;QAC3B9B,GAAG,GAAGpE,UAAU,CAACoE,GAAG,EAAEoC,WAAW,CAAClD,KAAK,GAAG,CAAC,CAAC;;MAGhD,IAAMoD,OAAO,GAAG7E,WAAW,CAAC4E,OAAO,EAAED,WAAW,CAAChF,QAAQ,CAAC;MAE1D,OAAO,IAAI2C,WAAW,CAAC5D,iBAAiB,EAAE6D,GAAG,EAAEsC,OAAO,EAAEF,WAAW,CAAC;IACxE;EAAC;IAAA3C,GAAA;IAAA9C,KAAA,EAED,SAAA4F,UAAiB5F,KAAgB,EAAEsD,MAAsC;MACrE,IAAIA,MAAM,IAAI,IAAI,EAAE;QAAEA,MAAM,GAAG,OAAO;;MAEtC,IAAMmC,WAAW,GAAGrD,WAAW,CAAC1C,IAAI,CAAC4D,MAAM,CAAC;MAE5C,IAAItE,QAAQ,CAACgB,KAAK,CAAC,CAACO,MAAM,GAAGkF,WAAW,CAAClD,KAAK,GAAG,CAAC,EAAE;QAChD,MAAM,IAAIsD,KAAK,CAAC,UAAU,CAAC;;MAG/B,IAAIH,OAAO,GAAGpG,SAAS,CAACI,IAAI,CAACM,KAAK,CAAC;MACnC,IAAIyF,WAAW,CAACnD,MAAM,EAAE;QAAEoD,OAAO,GAAGA,OAAO,CAACN,QAAQ,CAACK,WAAW,CAAClD,KAAK,CAAC;;MAEvE,IAAMc,GAAG,GAAGqC,OAAO,CAACL,MAAM,CAAC,CAACI,WAAW,CAACnD,MAAM,GAAG,CAAC,GAAE,CAAC,IAAImD,WAAW,CAAClD,KAAK,CAAC,CAAC4C,WAAW,EAAE;MACzF,IAAMQ,OAAO,GAAG7E,WAAW,CAAC4E,OAAO,EAAED,WAAW,CAAChF,QAAQ,CAAC;MAE1D,OAAO,IAAI2C,WAAW,CAAC5D,iBAAiB,EAAE6D,GAAG,EAAEsC,OAAO,EAAEF,WAAW,CAAC;IACxE;EAAC;IAAA3C,GAAA;IAAA9C,KAAA,EAED,SAAAN,KAAYM,KAAU,EAAEsD,MAAsC;MAC1D,IAAI,OAAOtD,KAAM,KAAK,QAAQ,EAAE;QAC5B,OAAOoD,WAAW,CAACoC,UAAU,CAACxF,KAAK,EAAEsD,MAAM,CAAC;;MAGhD,IAAIpE,OAAO,CAACc,KAAK,CAAC,EAAE;QAChB,OAAOoD,WAAW,CAACwC,SAAS,CAAC5F,KAAK,EAAEsD,MAAM,CAAC;;MAG/C,IAAI;QACA,OAAOF,WAAW,CAACa,SAAS,CAACjE,KAAK,EAAE,CAAC,EAAEsD,MAAM,CAAC;OACjD,CAAC,OAAOwC,KAAK,EAAE;QACZ;QACA,IAAIA,KAAK,CAACC,IAAI,KAAK5G,MAAM,CAACiB,MAAM,CAAC4F,gBAAgB,EAAE;UAC/C,MAAMF,KAAK;;;MAInB,OAAOzG,MAAM,CAACwB,kBAAkB,CAAC,2BAA2B,EAAE,OAAO,EAAEb,KAAK,CAAC;IACjF;EAAC;IAAA8C,GAAA;IAAA9C,KAAA,EAED,SAAAiG,cAAqBjG,KAAU;MAC3B,OAAO,CAAC,EAAEA,KAAK,IAAIA,KAAK,CAAC2D,cAAc,CAAC;IAC5C;EAAC;EAAA,OAAAP,WAAA;AAAA;AAGL,IAAMuB,GAAG,GAAGvB,WAAW,CAAC1D,IAAI,CAAC,CAAC,CAAC;AAC/B,IAAMsF,IAAI,GAAG5B,WAAW,CAAC1D,IAAI,CAAC,KAAK,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}