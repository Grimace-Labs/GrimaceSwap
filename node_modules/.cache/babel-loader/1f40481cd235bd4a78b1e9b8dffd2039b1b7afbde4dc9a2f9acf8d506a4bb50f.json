{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n  password = arrayify(password);\n  salt = arrayify(salt);\n  var hLen;\n  var l = 1;\n  var DK = new Uint8Array(keylen);\n  var block1 = new Uint8Array(salt.length + 4);\n  block1.set(salt);\n  //salt.copy(block1, 0, 0, salt.length)\n  var r;\n  var T;\n  for (var i = 1; i <= l; i++) {\n    //block1.writeUInt32BE(i, salt.length)\n    block1[salt.length] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i & 0xff;\n    //let U = createHmac(password).update(block1).digest();\n    var U = arrayify(computeHmac(hashAlgorithm, password, block1));\n    if (!hLen) {\n      hLen = U.length;\n      T = new Uint8Array(hLen);\n      l = Math.ceil(keylen / hLen);\n      r = keylen - (l - 1) * hLen;\n    }\n    //U.copy(T, 0, 0, hLen)\n    T.set(U);\n    for (var j = 1; j < iterations; j++) {\n      //U = createHmac(password).update(U).digest();\n      U = arrayify(computeHmac(hashAlgorithm, password, U));\n      for (var k = 0; k < hLen; k++) T[k] ^= U[k];\n    }\n    var destPos = (i - 1) * hLen;\n    var len = i === l ? r : hLen;\n    //T.copy(DK, destPos, 0, len)\n    DK.set(arrayify(T).slice(0, len), destPos);\n  }\n  return hexlify(DK);\n}","map":{"version":3,"names":["arrayify","hexlify","computeHmac","pbkdf2","password","salt","iterations","keylen","hashAlgorithm","hLen","l","DK","Uint8Array","block1","length","set","r","T","i","U","Math","ceil","j","k","destPos","len","slice"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\pbkdf2\\src.ts\\browser-pbkdf2.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n"],"mappings":"AAAA,YAAY;;AAEZ,SAASA,QAAQ,EAAaC,OAAO,QAAQ,sBAAsB;AACnE,SAASC,WAAW,QAA4B,qBAAqB;AAErE,OAAM,SAAUC,MAAMA,CAACC,QAAmB,EAAEC,IAAe,EAAEC,UAAkB,EAAEC,MAAc,EAAEC,aAAqB;EAClHJ,QAAQ,GAAGJ,QAAQ,CAACI,QAAQ,CAAC;EAC7BC,IAAI,GAAGL,QAAQ,CAACK,IAAI,CAAC;EACrB,IAAII,IAAI;EACR,IAAIC,CAAC,GAAG,CAAC;EACT,IAAMC,EAAE,GAAG,IAAIC,UAAU,CAACL,MAAM,CAAC;EACjC,IAAMM,MAAM,GAAG,IAAID,UAAU,CAACP,IAAI,CAACS,MAAM,GAAG,CAAC,CAAC;EAC9CD,MAAM,CAACE,GAAG,CAACV,IAAI,CAAC;EAChB;EAEA,IAAIW,CAAS;EACb,IAAIC,CAAa;EAEjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIR,CAAC,EAAEQ,CAAC,EAAE,EAAE;IACzB;IACAL,MAAM,CAACR,IAAI,CAACS,MAAM,CAAC,GAAII,CAAC,IAAI,EAAE,GAAI,IAAI;IACtCL,MAAM,CAACR,IAAI,CAACS,MAAM,GAAG,CAAC,CAAC,GAAII,CAAC,IAAI,EAAE,GAAI,IAAI;IAC1CL,MAAM,CAACR,IAAI,CAACS,MAAM,GAAG,CAAC,CAAC,GAAII,CAAC,IAAI,CAAC,GAAI,IAAI;IACzCL,MAAM,CAACR,IAAI,CAACS,MAAM,GAAG,CAAC,CAAC,GAAGI,CAAC,GAAG,IAAI;IAElC;IACA,IAAIC,CAAC,GAAGnB,QAAQ,CAACE,WAAW,CAAqBM,aAAa,EAAEJ,QAAQ,EAAES,MAAM,CAAC,CAAC;IAElF,IAAI,CAACJ,IAAI,EAAE;MACPA,IAAI,GAAGU,CAAC,CAACL,MAAM;MACfG,CAAC,GAAG,IAAIL,UAAU,CAACH,IAAI,CAAC;MACxBC,CAAC,GAAGU,IAAI,CAACC,IAAI,CAACd,MAAM,GAAGE,IAAI,CAAC;MAC5BO,CAAC,GAAGT,MAAM,GAAG,CAACG,CAAC,GAAG,CAAC,IAAID,IAAI;;IAG/B;IACAQ,CAAC,CAACF,GAAG,CAACI,CAAC,CAAC;IAGR,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,UAAU,EAAEgB,CAAC,EAAE,EAAE;MACjC;MACAH,CAAC,GAAGnB,QAAQ,CAACE,WAAW,CAAqBM,aAAa,EAAEJ,QAAQ,EAAEe,CAAC,CAAC,CAAC;MACzE,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,EAAEc,CAAC,EAAE,EAAEN,CAAC,CAACM,CAAC,CAAC,IAAIJ,CAAC,CAACI,CAAC,CAAC;;IAI/C,IAAMC,OAAO,GAAG,CAACN,CAAC,GAAG,CAAC,IAAIT,IAAI;IAC9B,IAAMgB,GAAG,GAAIP,CAAC,KAAKR,CAAC,GAAGM,CAAC,GAAGP,IAAK;IAChC;IACAE,EAAE,CAACI,GAAG,CAACf,QAAQ,CAACiB,CAAC,CAAC,CAACS,KAAK,CAAC,CAAC,EAAED,GAAG,CAAC,EAAED,OAAO,CAAC;;EAG9C,OAAOvB,OAAO,CAACU,EAAE,CAAC;AACtB"},"metadata":{},"sourceType":"module","externalDependencies":[]}