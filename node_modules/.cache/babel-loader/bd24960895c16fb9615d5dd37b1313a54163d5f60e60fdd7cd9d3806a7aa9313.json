{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case \"address\":\n      if (isArray) {\n        return zeroPad(value, 32);\n      }\n      return arrayify(value);\n    case \"string\":\n      return toUtf8Bytes(value);\n    case \"bytes\":\n      return arrayify(value);\n    case \"bool\":\n      value = value ? \"0x01\" : \"0x00\";\n      if (isArray) {\n        return zeroPad(value, 32);\n      }\n      return arrayify(value);\n  }\n  let match = type.match(regexNumber);\n  if (match) {\n    //let signed = (match[1] === \"int\")\n    let size = parseInt(match[2] || \"256\");\n    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {\n      throw new Error(\"invalid number type - \" + type);\n    }\n    if (isArray) {\n      size = 256;\n    }\n    value = BigNumber.from(value).toTwos(size);\n    return zeroPad(value, size / 8);\n  }\n  match = type.match(regexBytes);\n  if (match) {\n    const size = parseInt(match[1]);\n    if (String(size) !== match[1] || size === 0 || size > 32) {\n      throw new Error(\"invalid bytes type - \" + type);\n    }\n    if (arrayify(value).byteLength !== size) {\n      throw new Error(\"invalid value for \" + type);\n    }\n    if (isArray) {\n      return arrayify((value + Zeros).substring(0, 66));\n    }\n    return value;\n  }\n  match = type.match(regexArray);\n  if (match && Array.isArray(value)) {\n    const baseType = match[1];\n    const count = parseInt(match[2] || String(value.length));\n    if (count != value.length) {\n      throw new Error(\"invalid value for \" + type);\n    }\n    const result = [];\n    value.forEach(function (value) {\n      result.push(_pack(baseType, value, true));\n    });\n    return concat(result);\n  }\n  throw new Error(\"invalid type - \" + type);\n}\n// @TODO: Array Enum\nexport function pack(types, values) {\n  if (types.length != values.length) {\n    throw new Error(\"type/value count mismatch\");\n  }\n  const tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return hexlify(concat(tight));\n}\nexport function keccak256(types, values) {\n  return hashKeccak256(pack(types, values));\n}\nexport function sha256(types, values) {\n  return hashSha256(pack(types, values));\n}","map":{"version":3,"names":["BigNumber","arrayify","concat","hexlify","zeroPad","keccak256","hashKeccak256","sha256","hashSha256","toUtf8Bytes","regexBytes","RegExp","regexNumber","regexArray","Zeros","_pack","type","value","isArray","match","size","parseInt","String","Error","from","toTwos","byteLength","substring","Array","baseType","count","length","result","forEach","push","pack","types","values","tight","index"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\solidity\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\": \"0x00\");\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\")\n\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            throw new Error(\"invalid number type - \" + type);\n        }\n\n        if (isArray) { size = 256; }\n\n        value = BigNumber.from(value).toTwos(size);\n\n        return zeroPad(value, size / 8);\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            throw new Error(\"invalid bytes type - \" + type);\n        }\n        if (arrayify(value).byteLength !== size) { throw new Error(\"invalid value for \" + type); }\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) { throw new Error(\"invalid value for \" + type); }\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n\n    throw new Error(\"invalid type - \" + type);\n}\n\n// @TODO: Array Enum\n\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    if (types.length != values.length) { throw new Error(\"type/value count mismatch\"); }\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashKeccak256(pack(types, values));\n}\n\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashSha256(pack(types, values));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}