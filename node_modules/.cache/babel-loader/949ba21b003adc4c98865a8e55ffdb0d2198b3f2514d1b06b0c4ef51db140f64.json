{"ast":null,"code":"import { Contract, ethers } from \"ethers\";\nimport * as chains from \"./constants/chains\";\nimport COINS from \"./constants/coins\";\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\nconst ERC20 = require(\"./build/ERC20.json\");\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\nexport function getProvider() {\n  return new ethers.providers.Web3Provider(window.ethereum);\n}\nexport function getSigner(provider) {\n  return provider.getSigner();\n}\nexport async function getNetwork(provider) {\n  const network = await provider.getNetwork();\n  return network.chainId;\n}\nexport function getRouter(address, signer) {\n  return new Contract(address, ROUTER.abi, signer);\n}\nexport async function checkNetwork(provider) {\n  const chainId = getNetwork(provider);\n  if (chains.networks.includes(chainId)) {\n    return true;\n  }\n  return false;\n}\nexport function getWeth(address, signer) {\n  return new Contract(address, ERC20.abi, signer);\n}\nexport function getFactory(address, signer) {\n  return new Contract(address, FACTORY.abi, signer);\n}\nexport async function getAccount() {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\"\n  });\n  return accounts[0];\n}\n\n//This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\nexport function doesTokenExist(address, signer) {\n  try {\n    return new Contract(address, ERC20.abi, signer);\n  } catch (err) {\n    return false;\n  }\n}\nexport async function getDecimals(token) {\n  const decimals = await token.decimals().then(result => {\n    return result;\n  }).catch(error => {\n    console.log('No tokenDecimals function for this token, set to 0');\n    return 0;\n  });\n  return decimals;\n}\nexport async function getAllowance(contractAddress, ownerAddress, spenderAddress, signer) {\n  const token = new Contract(contractAddress, ERC20.abi, signer);\n  try {\n    // Call the allowance method on the contract to get the allowance amount\n    const allowance = await token.allowance(ownerAddress, spenderAddress);\n\n    // Convert the allowance value from BigNumber to a human-readable format\n    return allowance;\n  } catch (error) {\n    console.error('Error retrieving allowance:', error);\n    return null;\n  }\n}\n\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function getBalanceAndSymbol(accountAddress, address, provider, signer, weth_address, coins) {\n  try {\n    if (address === weth_address) {\n      const balanceRaw = await provider.getBalance(accountAddress);\n      return {\n        balance: ethers.utils.formatEther(balanceRaw),\n        symbol: coins[0].abbr\n      };\n    } else {\n      const token = new Contract(address, ERC20.abi, signer);\n      const tokenDecimals = await getDecimals(token);\n      const balanceRaw = await token.balanceOf(accountAddress);\n      const symbol = await token.symbol();\n      return {\n        balance: balanceRaw * 10 ** -tokenDecimals,\n        balanceRaw: balanceRaw,\n        symbol: symbol\n      };\n    }\n  } catch (error) {\n    console.log('The getBalanceAndSymbol function had an error!');\n    console.log(error);\n    return false;\n  }\n}\nexport async function approveToken(contractAddress, spenderAddress, signer) {\n  const token = new ethers.Contract(contractAddress, ERC20.abi, signer);\n  const maxUint256 = ethers.constants.MaxUint256;\n  await token.approve(spenderAddress, maxUint256).then(async tx => {\n    await tx.wait();\n  });\n}\n\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\nexport async function swapTokens(address1, address2, amount, routerContract, accountAddress, signer) {\n  const tokens = [address1, address2];\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const tokenDecimals = await getDecimals(token1);\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\n  const amountOut = await routerContract.callStatic.getAmountsOut(amountIn, tokens);\n  const wethAddress = await routerContract.WETH();\n  if (address1 === wethAddress) {\n    // Eth -> Token\n    await routerContract.swapExactETHForTokens(amountOut[1], tokens, accountAddress, deadline, {\n      value: amountIn\n    });\n  } else if (address2 === wethAddress) {\n    // Token -> Eth\n    await routerContract.swapExactTokensForETH(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  } else {\n    await routerContract.swapExactTokensForTokens(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  }\n}\n\n//This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\nexport async function getAmountOut(address1, address2, amountIn, routerContract, signer) {\n  try {\n    const token1 = new Contract(address1, ERC20.abi, signer);\n    const token1Decimals = await getDecimals(token1);\n    const token2 = new Contract(address2, ERC20.abi, signer);\n    const token2Decimals = await getDecimals(token2);\n    const values_out = await routerContract.getAmountsOut(ethers.utils.parseUnits(String(amountIn), token1Decimals), [address1, address2]);\n    const amount_out = values_out[1] * 10 ** -token2Decimals;\n    console.log('amount out: ', amount_out);\n    return Number(amount_out);\n  } catch {\n    return false;\n  }\n}\n\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\nexport async function fetchReserves(address1, address2, pair, signer) {\n  try {\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n    const coin1Decimals = await getDecimals(coin1);\n    const coin2Decimals = await getDecimals(coin2);\n\n    // Get reserves\n    const reservesRaw = await pair.getReserves();\n\n    // Put the results in the right order\n    const results = [(await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1], (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0]];\n\n    // Scale each to the right decimal place\n    return [results[0] * 10 ** -coin1Decimals, results[1] * 10 ** -coin2Decimals, reservesRaw];\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0, null];\n  }\n}\n\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\nexport async function getReserves(address1, address2, factory, signer) {\n  try {\n    const pairAddress = await factory.getPair(address1, address2);\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\n    if (pairAddress !== '0x0000000000000000000000000000000000000000') {\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\n      return [reservesRaw[0].toPrecision(6), reservesRaw[1].toPrecision(6), reservesRaw[2]];\n    } else {\n      console.log(\"no reserves yet\");\n      return [0, 0, 0];\n    }\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0, 0];\n  }\n}","map":{"version":3,"names":["Contract","ethers","chains","COINS","ROUTER","require","ERC20","FACTORY","PAIR","getProvider","providers","Web3Provider","window","ethereum","getSigner","provider","getNetwork","network","chainId","getRouter","address","signer","abi","checkNetwork","networks","includes","getWeth","getFactory","getAccount","accounts","request","method","doesTokenExist","err","getDecimals","token","decimals","then","result","catch","error","console","log","getAllowance","contractAddress","ownerAddress","spenderAddress","allowance","getBalanceAndSymbol","accountAddress","weth_address","coins","balanceRaw","getBalance","balance","utils","formatEther","symbol","abbr","tokenDecimals","balanceOf","approveToken","maxUint256","constants","MaxUint256","approve","tx","wait","swapTokens","address1","address2","amount","routerContract","tokens","time","Math","floor","Date","now","deadline","BigNumber","from","token1","amountIn","parseUnits","amountOut","callStatic","getAmountsOut","wethAddress","WETH","swapExactETHForTokens","value","swapExactTokensForETH","swapExactTokensForTokens","getAmountOut","token1Decimals","token2","token2Decimals","values_out","String","amount_out","Number","fetchReserves","pair","coin1","coin2","coin1Decimals","coin2Decimals","reservesRaw","getReserves","results","token0","factory","pairAddress","getPair","toPrecision"],"sources":["D:/temki/grimace/GrimaceSwap/src/ethereumFunctions.js"],"sourcesContent":["import { Contract, ethers } from \"ethers\";\r\nimport * as chains from \"./constants/chains\";\r\nimport COINS from \"./constants/coins\";\r\n\r\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\r\nconst ERC20 = require(\"./build/ERC20.json\");\r\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\r\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\r\n\r\nexport function getProvider() {\r\n  return new ethers.providers.Web3Provider(window.ethereum);\r\n}\r\n\r\nexport function getSigner(provider) {\r\n  return provider.getSigner();\r\n}\r\n\r\nexport async function getNetwork(provider) {\r\n  const network = await provider.getNetwork();\r\n  return network.chainId;\r\n}\r\n\r\nexport function getRouter(address, signer) {\r\n  return new Contract(address, ROUTER.abi, signer);\r\n}\r\n\r\nexport async function checkNetwork(provider) {\r\n  const chainId = getNetwork(provider);\r\n  if (chains.networks.includes(chainId)){\r\n    return true\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function getWeth(address, signer) {\r\n  return new Contract(address, ERC20.abi, signer);\r\n}\r\n\r\nexport function getFactory(address, signer) {\r\n  return new Contract(address, FACTORY.abi, signer);\r\n}\r\n\r\nexport async function getAccount() {\r\n  const accounts = await window.ethereum.request({\r\n    method: \"eth_requestAccounts\",\r\n  });\r\n\r\n  return accounts[0];\r\n}\r\n\r\n//This function checks if a ERC20 token exists for a given address\r\n//    `address` - The Ethereum address to be checked\r\n//    `signer` - The current signer\r\nexport function doesTokenExist(address, signer) {\r\n  try {\r\n    return new Contract(address, ERC20.abi, signer);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function getDecimals(token) {\r\n  const decimals = await token.decimals().then((result) => {\r\n      return result;\r\n    }).catch((error) => {\r\n      console.log('No tokenDecimals function for this token, set to 0');\r\n      return 0;\r\n    });\r\n    return decimals;\r\n}\r\n\r\nexport async function getAllowance(contractAddress, ownerAddress, spenderAddress, signer){\r\n  const token = new Contract(contractAddress, ERC20.abi, signer);\r\n\r\n  try {\r\n    // Call the allowance method on the contract to get the allowance amount\r\n    const allowance = await token.allowance(ownerAddress, spenderAddress);\r\n\r\n    // Convert the allowance value from BigNumber to a human-readable format\r\n    return allowance;\r\n  } catch (error) {\r\n    console.error('Error retrieving allowance:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\r\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\r\n//    `provider` - The current provider\r\n//    `signer` - The current signer\r\nexport async function getBalanceAndSymbol(\r\n  accountAddress,\r\n  address,\r\n  provider,\r\n  signer,\r\n  weth_address,\r\n  coins\r\n) {\r\n  try {\r\n    if (address === weth_address) {\r\n      const balanceRaw = await provider.getBalance(accountAddress);\r\n\r\n      return {\r\n        balance: ethers.utils.formatEther(balanceRaw),\r\n        symbol: coins[0].abbr,\r\n      };\r\n    } else {\r\n      const token = new Contract(address, ERC20.abi, signer);\r\n      const tokenDecimals = await getDecimals(token);\r\n      const balanceRaw = await token.balanceOf(accountAddress);\r\n      const symbol = await token.symbol();\r\n\r\n      return {\r\n        balance: balanceRaw*10**(-tokenDecimals),\r\n        balanceRaw: balanceRaw,\r\n        symbol: symbol,\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.log ('The getBalanceAndSymbol function had an error!');\r\n    console.log (error)\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function approveToken(contractAddress, spenderAddress, signer){\r\n  const token = new ethers.Contract(contractAddress, ERC20.abi, signer);\r\n\r\n  const maxUint256 = ethers.constants.MaxUint256;\r\n  await token.approve(spenderAddress, maxUint256).then(async (tx) => {\r\n    await tx.wait();\r\n  })\r\n}\r\n\r\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\r\n// No error handling is done, so any issues can be caught with the use of .catch()\r\n// To work correctly, there needs to be 7 arguments:\r\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\r\n//    `amount` - A float or similar number representing the value of address1's token to trade\r\n//    `routerContract` - The router contract to carry out this trade\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `signer` - The current signer\r\nexport async function swapTokens(\r\n  address1,\r\n  address2,\r\n  amount,\r\n  routerContract,\r\n  accountAddress,\r\n  signer\r\n) {\r\n  const tokens = [address1, address2];\r\n  const time = Math.floor(Date.now() / 1000) + 200000;\r\n  const deadline = ethers.BigNumber.from(time);\r\n\r\n  const token1 = new Contract(address1, ERC20.abi, signer);\r\n  const tokenDecimals = await getDecimals(token1);\r\n  \r\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\r\n  const amountOut = await routerContract.callStatic.getAmountsOut(\r\n    amountIn,\r\n    tokens\r\n  );\r\n\r\n  const wethAddress = await routerContract.WETH();\r\n\r\n  if (address1 === wethAddress) {\r\n    // Eth -> Token\r\n    await routerContract.swapExactETHForTokens(\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline,\r\n      { value: amountIn }\r\n    );\r\n  } else if (address2 === wethAddress) {\r\n    // Token -> Eth\r\n    await routerContract.swapExactTokensForETH(\r\n      amountIn,\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline\r\n    );\r\n  } else {\r\n    await routerContract.swapExactTokensForTokens(\r\n      amountIn,\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline\r\n    );\r\n  }\r\n}\r\n\r\n//This function returns the conversion rate between two token addresses\r\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\r\n//    `amountIn` - Amount of the token at address 1 to be swaped from\r\n//    `routerContract` - The router contract to carry out this swap\r\nexport async function getAmountOut(\r\n  address1,\r\n  address2,\r\n  amountIn,\r\n  routerContract,\r\n  signer\r\n) {\r\n  try {\r\n    const token1 = new Contract(address1, ERC20.abi, signer);\r\n    const token1Decimals = await getDecimals(token1);\r\n\r\n    const token2 = new Contract(address2, ERC20.abi, signer);\r\n    const token2Decimals = await getDecimals(token2);\r\n\r\n    const values_out = await routerContract.getAmountsOut(\r\n      ethers.utils.parseUnits(String(amountIn), token1Decimals),\r\n      [address1, address2]\r\n    );\r\n    const amount_out = values_out[1]*10**(-token2Decimals);\r\n    console.log('amount out: ', amount_out)\r\n    return Number(amount_out);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\r\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\r\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\r\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\r\n//    `pair` - The pair contract for the two tokens\r\nexport async function fetchReserves(address1, address2, pair, signer) {\r\n  try {\r\n\r\n    // Get decimals for each coin\r\n    const coin1 = new Contract(address1, ERC20.abi, signer);\r\n    const coin2 = new Contract(address2, ERC20.abi, signer);\r\n\r\n    const coin1Decimals = await getDecimals(coin1);\r\n    const coin2Decimals = await getDecimals(coin2);\r\n\r\n    // Get reserves\r\n    const reservesRaw = await pair.getReserves();\r\n\r\n    // Put the results in the right order\r\n    const results =  [\r\n      (await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1],\r\n      (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0],\r\n    ];\r\n\r\n    // Scale each to the right decimal place\r\n    return [\r\n      (results[0]*10**(-coin1Decimals)),\r\n      (results[1]*10**(-coin2Decimals)),\r\n      reservesRaw\r\n    ]\r\n  } catch (err) {\r\n    console.log(\"error!\");\r\n    console.log(err);\r\n    return [0, 0, null];\r\n  }\r\n}\r\n\r\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\r\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\r\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\r\n//    `factory` - The current factory\r\n//    `signer` - The current signer\r\nexport async function getReserves(\r\n  address1,\r\n  address2,\r\n  factory,\r\n  signer,\r\n) {\r\n  try {\r\n    const pairAddress = await factory.getPair(address1, address2);\r\n    const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n  \r\n    if (pairAddress !== '0x0000000000000000000000000000000000000000'){\r\n  \r\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer);\r\n    \r\n      return [\r\n        reservesRaw[0].toPrecision(6),\r\n        reservesRaw[1].toPrecision(6),\r\n        reservesRaw[2],\r\n      ];\r\n    } else {\r\n      console.log(\"no reserves yet\");\r\n      return [0,0,0];\r\n    }\r\n  }catch (err) {\r\n    console.log(\"error!\");\r\n    console.log(err);\r\n    return [0, 0, 0];\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}