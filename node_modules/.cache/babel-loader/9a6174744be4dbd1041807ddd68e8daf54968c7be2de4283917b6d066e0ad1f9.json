{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexDataLength, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar _curve = null;\nfunction getCurve() {\n  if (!_curve) {\n    _curve = new EC(\"secp256k1\");\n  }\n  return _curve;\n}\nexport var SigningKey = /*#__PURE__*/function () {\n  function SigningKey(privateKey) {\n    _classCallCheck(this, SigningKey);\n    defineReadOnly(this, \"curve\", \"secp256k1\");\n    defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n    if (hexDataLength(this.privateKey) !== 32) {\n      logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n    }\n    var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n    defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n    defineReadOnly(this, \"_isSigningKey\", true);\n  }\n  _createClass(SigningKey, [{\n    key: \"_addPoint\",\n    value: function _addPoint(other) {\n      var p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n      var p1 = getCurve().keyFromPublic(arrayify(other));\n      return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n  }, {\n    key: \"signDigest\",\n    value: function signDigest(digest) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var digestBytes = arrayify(digest);\n      if (digestBytes.length !== 32) {\n        logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n      }\n      var signature = keyPair.sign(digestBytes, {\n        canonical: true\n      });\n      return splitSignature({\n        recoveryParam: signature.recoveryParam,\n        r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n        s: hexZeroPad(\"0x\" + signature.s.toString(16), 32)\n      });\n    }\n  }, {\n    key: \"computeSharedSecret\",\n    value: function computeSharedSecret(otherKey) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n      return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n  }], [{\n    key: \"isSigningKey\",\n    value: function isSigningKey(value) {\n      return !!(value && value._isSigningKey);\n    }\n  }]);\n  return SigningKey;\n}();\nexport function recoverPublicKey(digest, signature) {\n  var sig = splitSignature(signature);\n  var rs = {\n    r: arrayify(sig.r),\n    s: arrayify(sig.s)\n  };\n  return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n  var bytes = arrayify(key);\n  if (bytes.length === 32) {\n    var signingKey = new SigningKey(bytes);\n    if (compressed) {\n      return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n    }\n    return signingKey.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return hexlify(bytes);\n    }\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return hexlify(bytes);\n    }\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n  }\n  return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}","map":{"version":3,"names":["_classCallCheck","_createClass","EC","arrayify","hexDataLength","hexlify","hexZeroPad","splitSignature","defineReadOnly","Logger","version","logger","_curve","getCurve","SigningKey","privateKey","throwArgumentError","keyPair","keyFromPrivate","getPublic","key","value","_addPoint","other","p0","keyFromPublic","publicKey","p1","pub","add","encodeCompressed","signDigest","digest","digestBytes","length","signature","sign","canonical","recoveryParam","r","toString","s","computeSharedSecret","otherKey","otherKeyPair","computePublicKey","derive","isSigningKey","_isSigningKey","recoverPublicKey","sig","rs","recoverPubKey","encode","compressed","bytes","signingKey"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\signing-key\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}