{"ast":null,"code":"\"use strict\";\n\nimport _createClass from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _regeneratorRuntime from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n  for (var i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n  return null;\n}\nexport function resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var promises, results;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          promises = Object.keys(object).map(function (key) {\n            var value = object[key];\n            return Promise.resolve(value).then(function (v) {\n              return {\n                key: key,\n                value: v\n              };\n            });\n          });\n          _context.next = 3;\n          return Promise.all(promises);\n        case 3:\n          results = _context.sent;\n          return _context.abrupt(\"return\", results.reduce(function (accum, result) {\n            accum[result.key] = result.value;\n            return accum;\n          }, {}));\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n  Object.keys(object).forEach(function (key) {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  var result = {};\n  for (var key in object) {\n    result[key] = object[key];\n  }\n  return result;\n}\nvar opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n    var keys = Object.keys(object);\n    for (var i = 0; i < keys.length; i++) {\n      var value = null;\n      try {\n        value = object[keys[i]];\n      } catch (error) {\n        // If accessing a value triggers an error, it is a getter\n        // designed to do so (e.g. Result) and is therefore \"frozen\"\n        continue;\n      }\n      if (!_isFrozen(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  }\n  // Arrays are mutable, so we need to create a copy\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(function (item) {\n      return deepCopy(item);\n    }));\n  }\n  if (typeof object === \"object\") {\n    var result = {};\n    for (var key in object) {\n      var value = object[key];\n      if (value === undefined) {\n        continue;\n      }\n      defineReadOnly(result, key, deepCopy(value));\n    }\n    return result;\n  }\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport var Description = /*#__PURE__*/_createClass(function Description(info) {\n  _classCallCheck(this, Description);\n  for (var key in info) {\n    this[key] = deepCopy(info[key]);\n  }\n});","map":{"version":3,"names":["_createClass","_classCallCheck","_regeneratorRuntime","Logger","version","logger","defineReadOnly","object","name","value","Object","defineProperty","enumerable","writable","getStatic","ctor","key","i","prototype","getPrototypeOf","constructor","resolveProperties","promises","keys","map","Promise","resolve","then","v","_context","next","all","results","sent","abrupt","reduce","accum","result","stop","_callee","checkProperties","properties","throwArgumentError","forEach","shallowCopy","opaque","bigint","boolean","number","string","_isFrozen","undefined","Array","isArray","isFrozen","length","error","concat","_deepCopy","freeze","item","deepCopy","Description","info"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\properties\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}