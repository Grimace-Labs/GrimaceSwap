{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"D:/temki/grimace/GrimaceSwap/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nfunction now() {\n  return new Date().getTime();\n}\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n  var result = null;\n  for (var i = 0; i < networks.length; i++) {\n    var network = networks[i];\n    // Null! We do not know our network; bail.\n    if (network == null) {\n      return null;\n    }\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n  return result;\n}\nfunction median(values, maxDelta) {\n  values = values.slice().sort();\n  var middle = Math.floor(values.length / 2);\n  // Odd length; take the middle\n  if (values.length % 2) {\n    return values[middle];\n  }\n  // Even length; take the average of the two middle\n  var a = values[middle - 1],\n    b = values[middle];\n  if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n    return null;\n  }\n  return (a + b) / 2;\n}\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(function (i) {\n      return serialize(i);\n    }));\n  } else if (typeof value === \"object\") {\n    var keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(function (key) {\n      var v = value[key];\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n  throw new Error(\"unknown value type: \" + typeof value);\n}\n// Next request ID to use for emitting debug info\nvar nextRid = 1;\n;\nfunction stall(duration) {\n  var cancel = null;\n  var timer = null;\n  var promise = new Promise(function (resolve) {\n    cancel = function cancel() {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      resolve();\n    };\n    timer = setTimeout(cancel, duration);\n  });\n  var wait = function wait(func) {\n    promise = promise.then(func);\n    return promise;\n  };\n  function getPromise() {\n    return promise;\n  }\n  return {\n    cancel: cancel,\n    getPromise: getPromise,\n    wait: wait\n  };\n}\nvar ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];\nvar ForwardProperties = [\"address\", \"args\", \"errorArgs\", \"errorSignature\", \"method\", \"transaction\"];\n;\nfunction exposeDebugConfig(config, now) {\n  var result = {\n    weight: config.weight\n  };\n  Object.defineProperty(result, \"provider\", {\n    get: function get() {\n      return config.provider;\n    }\n  });\n  if (config.start) {\n    result.start = config.start;\n  }\n  if (now) {\n    result.duration = now - config.start;\n  }\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n  return result;\n}\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    var tally = {};\n    configs.forEach(function (c) {\n      var value = normalize(c.result);\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n      tally[value].count++;\n    });\n    // Check for a quorum on any given result\n    var keys = Object.keys(tally);\n    for (var i = 0; i < keys.length; i++) {\n      var check = tally[keys[i]];\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    }\n    // No quroum\n    return undefined;\n  };\n}\nfunction getProcessFunc(provider, method, params) {\n  var normalize = serialize;\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        var values = configs.map(function (c) {\n          return c.result;\n        });\n        // Get the median block number\n        var blockNumber = median(configs.map(function (c) {\n          return c.result;\n        }), 2);\n        if (blockNumber == null) {\n          return undefined;\n        }\n        blockNumber = Math.ceil(blockNumber);\n        // If the next block height is present, its prolly safe to use\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        }\n        // Don't ever roll back the blockNumber\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n        return provider._highestBlockNumber;\n      };\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        var values = configs.map(function (c) {\n          return c.result;\n        });\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(function (c) {\n          return c.result;\n        }));\n      };\n    // No additional normalizing required; serialize is enough\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function normalize(tx) {\n        if (tx == null) {\n          return null;\n        }\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n      break;\n    // We drop the confirmations from transactions as it is approximate\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function normalize(block) {\n          if (block == null) {\n            return null;\n          }\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(function (tx) {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function normalize(block) {\n          if (block == null) {\n            return null;\n          }\n          return serialize(block);\n        };\n      }\n      break;\n    default:\n      throw new Error(\"unknown method: \" + method);\n  }\n  // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n  return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var provider;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          provider = config.provider;\n          if (!(provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1)) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt(\"return\", provider);\n        case 3:\n          return _context.abrupt(\"return\", poll(function () {\n            return new Promise(function (resolve, reject) {\n              setTimeout(function () {\n                // We are synced\n                if (provider.blockNumber >= blockNumber) {\n                  return resolve(provider);\n                }\n                // We're done; just quit\n                if (config.cancelled) {\n                  return resolve(null);\n                }\n                // Try again, next block\n                return resolve(undefined);\n              }, 0);\n            });\n          }, {\n            oncePoll: provider\n          }));\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var provider, filter;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          provider = config.provider;\n          _context2.t0 = method;\n          _context2.next = _context2.t0 === \"getBlockNumber\" ? 4 : _context2.t0 === \"getGasPrice\" ? 4 : _context2.t0 === \"getEtherPrice\" ? 5 : _context2.t0 === \"getBalance\" ? 8 : _context2.t0 === \"getTransactionCount\" ? 8 : _context2.t0 === \"getCode\" ? 8 : _context2.t0 === \"getStorageAt\" ? 13 : _context2.t0 === \"getBlock\" ? 18 : _context2.t0 === \"call\" ? 23 : _context2.t0 === \"estimateGas\" ? 23 : _context2.t0 === \"getTransaction\" ? 28 : _context2.t0 === \"getTransactionReceipt\" ? 28 : _context2.t0 === \"getLogs\" ? 29 : 35;\n          break;\n        case 4:\n          return _context2.abrupt(\"return\", provider[method]());\n        case 5:\n          if (!provider.getEtherPrice) {\n            _context2.next = 7;\n            break;\n          }\n          return _context2.abrupt(\"return\", provider.getEtherPrice());\n        case 7:\n          return _context2.abrupt(\"break\", 35);\n        case 8:\n          if (!(params.blockTag && isHexString(params.blockTag))) {\n            _context2.next = 12;\n            break;\n          }\n          _context2.next = 11;\n          return waitForSync(config, currentBlockNumber);\n        case 11:\n          provider = _context2.sent;\n        case 12:\n          return _context2.abrupt(\"return\", provider[method](params.address, params.blockTag || \"latest\"));\n        case 13:\n          if (!(params.blockTag && isHexString(params.blockTag))) {\n            _context2.next = 17;\n            break;\n          }\n          _context2.next = 16;\n          return waitForSync(config, currentBlockNumber);\n        case 16:\n          provider = _context2.sent;\n        case 17:\n          return _context2.abrupt(\"return\", provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\"));\n        case 18:\n          if (!(params.blockTag && isHexString(params.blockTag))) {\n            _context2.next = 22;\n            break;\n          }\n          _context2.next = 21;\n          return waitForSync(config, currentBlockNumber);\n        case 21:\n          provider = _context2.sent;\n        case 22:\n          return _context2.abrupt(\"return\", provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash));\n        case 23:\n          if (!(params.blockTag && isHexString(params.blockTag))) {\n            _context2.next = 27;\n            break;\n          }\n          _context2.next = 26;\n          return waitForSync(config, currentBlockNumber);\n        case 26:\n          provider = _context2.sent;\n        case 27:\n          return _context2.abrupt(\"return\", provider[method](params.transaction));\n        case 28:\n          return _context2.abrupt(\"return\", provider[method](params.transactionHash));\n        case 29:\n          filter = params.filter;\n          if (!(filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock))) {\n            _context2.next = 34;\n            break;\n          }\n          _context2.next = 33;\n          return waitForSync(config, currentBlockNumber);\n        case 33:\n          provider = _context2.sent;\n        case 34:\n          return _context2.abrupt(\"return\", provider.getLogs(filter));\n        case 35:\n          return _context2.abrupt(\"return\", logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n          }));\n        case 36:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n}\nexport var FallbackProvider = /*#__PURE__*/function (_BaseProvider) {\n  _inherits(FallbackProvider, _BaseProvider);\n  var _super = _createSuper(FallbackProvider);\n  function FallbackProvider(providers, quorum) {\n    var _this;\n    _classCallCheck(this, FallbackProvider);\n    logger.checkNew(this instanceof FallbackProvider ? this.constructor : void 0, FallbackProvider);\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n    var providerConfigs = providers.map(function (configOrProvider, index) {\n      if (Provider.isProvider(configOrProvider)) {\n        var stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n        var priority = 1;\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout: stallTimeout,\n          priority: priority\n        });\n      }\n      var config = shallowCopy(configOrProvider);\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n      if (config.stallTimeout == null) {\n        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n      }\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n      var weight = config.weight;\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\".concat(index, \"].weight\"), weight);\n      }\n      return Object.freeze(config);\n    });\n    var total = providerConfigs.reduce(function (accum, c) {\n      return accum + c.weight;\n    }, 0);\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    }\n    // Are all providers' networks are known\n    var networkOrReady = checkNetworks(providerConfigs.map(function (c) {\n      return c.provider.network;\n    }));\n    // Not all networks are known; we must stall\n    if (networkOrReady == null) {\n      networkOrReady = new Promise(function (resolve, reject) {\n        setTimeout(function () {\n          _this.detectNetwork().then(resolve, reject);\n        }, 0);\n      });\n    }\n    _this = _super.call(this, networkOrReady);\n    // Preserve a copy, so we do not get mutated\n    defineReadOnly(_assertThisInitialized(_this), \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(_assertThisInitialized(_this), \"quorum\", quorum);\n    _this._highestBlockNumber = -1;\n    return _this;\n  }\n  _createClass(FallbackProvider, [{\n    key: \"detectNetwork\",\n    value: function detectNetwork() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var networks;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return Promise.all(this.providerConfigs.map(function (c) {\n                return c.provider.getNetwork();\n              }));\n            case 2:\n              networks = _context3.sent;\n              return _context3.abrupt(\"return\", checkNetworks(networks));\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"perform\",\n    value: function perform(method, params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n        var results, _i, result, processFunc, configs, currentBlockNumber, i, first, _loop, _ret;\n        return _regeneratorRuntime().wrap(function _callee4$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(method === \"sendTransaction\")) {\n                _context6.next = 13;\n                break;\n              }\n              _context6.next = 3;\n              return Promise.all(this.providerConfigs.map(function (c) {\n                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n                  return result.hash;\n                }, function (error) {\n                  return error;\n                });\n              }));\n            case 3:\n              results = _context6.sent;\n              _i = 0;\n            case 5:\n              if (!(_i < results.length)) {\n                _context6.next = 12;\n                break;\n              }\n              result = results[_i];\n              if (!(typeof result === \"string\")) {\n                _context6.next = 9;\n                break;\n              }\n              return _context6.abrupt(\"return\", result);\n            case 9:\n              _i++;\n              _context6.next = 5;\n              break;\n            case 12:\n              throw results[0];\n            case 13:\n              if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) {\n                _context6.next = 16;\n                break;\n              }\n              _context6.next = 16;\n              return this.getBlockNumber();\n            case 16:\n              processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we\n              // shallowCopy them since we will store the result in them too\n              configs = shuffled(this.providerConfigs.map(shallowCopy));\n              configs.sort(function (a, b) {\n                return a.priority - b.priority;\n              });\n              currentBlockNumber = this._highestBlockNumber;\n              i = 0;\n              first = true;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var t0, inflightWeight, _loop2, waiting, results, _result, errors;\n                return _regeneratorRuntime().wrap(function _loop$(_context5) {\n                  while (1) switch (_context5.prev = _context5.next) {\n                    case 0:\n                      t0 = now(); // Compute the inflight weight (exclude anything past)\n                      inflightWeight = configs.filter(function (c) {\n                        return c.runner && t0 - c.start < c.stallTimeout;\n                      }).reduce(function (accum, c) {\n                        return accum + c.weight;\n                      }, 0); // Start running enough to meet quorum\n                      _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n                        var config, rid;\n                        return _regeneratorRuntime().wrap(function _loop2$(_context4) {\n                          while (1) switch (_context4.prev = _context4.next) {\n                            case 0:\n                              config = configs[i++];\n                              rid = nextRid++;\n                              config.start = now();\n                              config.staller = stall(config.stallTimeout);\n                              config.staller.wait(function () {\n                                config.staller = null;\n                              });\n                              config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n                                config.done = true;\n                                config.result = result;\n                                if (_this2.listenerCount(\"debug\")) {\n                                  _this2.emit(\"debug\", {\n                                    action: \"request\",\n                                    rid: rid,\n                                    backend: exposeDebugConfig(config, now()),\n                                    request: {\n                                      method: method,\n                                      params: deepCopy(params)\n                                    },\n                                    provider: _this2\n                                  });\n                                }\n                              }, function (error) {\n                                config.done = true;\n                                config.error = error;\n                                if (_this2.listenerCount(\"debug\")) {\n                                  _this2.emit(\"debug\", {\n                                    action: \"request\",\n                                    rid: rid,\n                                    backend: exposeDebugConfig(config, now()),\n                                    request: {\n                                      method: method,\n                                      params: deepCopy(params)\n                                    },\n                                    provider: _this2\n                                  });\n                                }\n                              });\n                              if (_this2.listenerCount(\"debug\")) {\n                                _this2.emit(\"debug\", {\n                                  action: \"request\",\n                                  rid: rid,\n                                  backend: exposeDebugConfig(config, null),\n                                  request: {\n                                    method: method,\n                                    params: deepCopy(params)\n                                  },\n                                  provider: _this2\n                                });\n                              }\n                              inflightWeight += config.weight;\n                            case 8:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }, _loop2);\n                      });\n                    case 3:\n                      if (!(inflightWeight < _this2.quorum && i < configs.length)) {\n                        _context5.next = 7;\n                        break;\n                      }\n                      return _context5.delegateYield(_loop2(), \"t0\", 5);\n                    case 5:\n                      _context5.next = 3;\n                      break;\n                    case 7:\n                      // Wait for anything meaningful to finish or stall out\n                      waiting = [];\n                      configs.forEach(function (c) {\n                        if (c.done || !c.runner) {\n                          return;\n                        }\n                        waiting.push(c.runner);\n                        if (c.staller) {\n                          waiting.push(c.staller.getPromise());\n                        }\n                      });\n                      if (!waiting.length) {\n                        _context5.next = 12;\n                        break;\n                      }\n                      _context5.next = 12;\n                      return Promise.race(waiting);\n                    case 12:\n                      // Check the quorum and process the results; the process function\n                      // may additionally decide the quorum is not met\n                      results = configs.filter(function (c) {\n                        return c.done && c.error == null;\n                      });\n                      if (!(results.length >= _this2.quorum)) {\n                        _context5.next = 22;\n                        break;\n                      }\n                      _result = processFunc(results);\n                      if (!(_result !== undefined)) {\n                        _context5.next = 18;\n                        break;\n                      }\n                      // Shut down any stallers\n                      configs.forEach(function (c) {\n                        if (c.staller) {\n                          c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                      });\n                      return _context5.abrupt(\"return\", {\n                        v: _result\n                      });\n                    case 18:\n                      if (first) {\n                        _context5.next = 21;\n                        break;\n                      }\n                      _context5.next = 21;\n                      return stall(100).getPromise();\n                    case 21:\n                      first = false;\n                    case 22:\n                      // No result, check for errors that should be forwarded\n                      errors = configs.reduce(function (accum, c) {\n                        if (!c.done || c.error == null) {\n                          return accum;\n                        }\n                        var code = c.error.code;\n                        if (ForwardErrors.indexOf(code) >= 0) {\n                          if (!accum[code]) {\n                            accum[code] = {\n                              error: c.error,\n                              weight: 0\n                            };\n                          }\n                          accum[code].weight += c.weight;\n                        }\n                        return accum;\n                      }, {});\n                      Object.keys(errors).forEach(function (errorCode) {\n                        var tally = errors[errorCode];\n                        if (tally.weight < _this2.quorum) {\n                          return;\n                        }\n                        // Shut down any stallers\n                        configs.forEach(function (c) {\n                          if (c.staller) {\n                            c.staller.cancel();\n                          }\n                          c.cancelled = true;\n                        });\n                        var e = tally.error;\n                        var props = {};\n                        ForwardProperties.forEach(function (name) {\n                          if (e[name] == null) {\n                            return;\n                          }\n                          props[name] = e[name];\n                        });\n                        logger.throwError(e.reason || e.message, errorCode, props);\n                      });\n                      // All configs have run to completion; we will never get more data\n                      if (!(configs.filter(function (c) {\n                        return !c.done;\n                      }).length === 0)) {\n                        _context5.next = 26;\n                        break;\n                      }\n                      return _context5.abrupt(\"return\", \"break\");\n                    case 26:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }, _loop);\n              });\n            case 23:\n              if (!true) {\n                _context6.next = 32;\n                break;\n              }\n              return _context6.delegateYield(_loop(), \"t0\", 25);\n            case 25:\n              _ret = _context6.t0;\n              if (!(_ret === \"break\")) {\n                _context6.next = 28;\n                break;\n              }\n              return _context6.abrupt(\"break\", 32);\n            case 28:\n              if (!(typeof _ret === \"object\")) {\n                _context6.next = 30;\n                break;\n              }\n              return _context6.abrupt(\"return\", _ret.v);\n            case 30:\n              _context6.next = 23;\n              break;\n            case 32:\n              // Shut down any stallers; shouldn't be any\n              configs.forEach(function (c) {\n                if (c.staller) {\n                  c.staller.cancel();\n                }\n                c.cancelled = true;\n              });\n              return _context6.abrupt(\"return\", logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map(function (c) {\n                  return exposeDebugConfig(c);\n                }),\n                provider: this\n              }));\n            case 34:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee4, this);\n      }));\n    }\n  }]);\n  return FallbackProvider;\n}(BaseProvider);","map":{"version":3,"names":["_classCallCheck","_createClass","_assertThisInitialized","_inherits","_createSuper","_regeneratorRuntime","Provider","BigNumber","isHexString","deepCopy","defineReadOnly","shallowCopy","shuffled","poll","BaseProvider","isCommunityResource","Logger","version","logger","now","Date","getTime","checkNetworks","networks","result","i","length","network","name","chainId","ensAddress","throwArgumentError","median","values","maxDelta","slice","sort","middle","Math","floor","a","b","abs","serialize","value","JSON","stringify","isBigNumber","toString","Array","isArray","map","keys","Object","key","v","join","Error","nextRid","stall","duration","cancel","timer","promise","Promise","resolve","clearTimeout","setTimeout","wait","func","then","getPromise","ForwardErrors","errors","CALL_EXCEPTION","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","provider","start","done","error","normalizedTally","normalize","quorum","configs","tally","forEach","c","count","check","undefined","getProcessFunc","method","params","blockNumber","ceil","indexOf","_highestBlockNumber","tx","confirmations","includeTransactions","block","transactions","waitForSync","_context","next","abrupt","reject","cancelled","oncePoll","stop","_callee","getRunner","currentBlockNumber","_context2","t0","getEtherPrice","blockTag","sent","address","getStorageAt","position","blockHash","transaction","transactionHash","filter","fromBlock","toBlock","getLogs","throwError","UNKNOWN_ERROR","_callee2","FallbackProvider","_BaseProvider","_super","providers","_this","checkNew","constructor","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","freeze","concat","total","reduce","accum","networkOrReady","detectNetwork","call","all","getNetwork","_context3","_callee3","perform","_context6","sendTransaction","signedTransaction","hash","results","getBlockNumber","processFunc","first","_loop","mark","inflightWeight","_loop2","waiting","_result","wrap","_loop$","_context5","prev","runner","rid","_loop2$","_context4","staller","_this2","listenerCount","emit","action","backend","request","delegateYield","push","race","code","errorCode","e","props","reason","message","_ret","SERVER_ERROR","_callee4"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\@ethersproject\\providers\\src.ts\\fallback-provider.ts"],"sourcesContent":["\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster retult.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        logger.checkNew(new.target, FallbackProvider);\n\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}