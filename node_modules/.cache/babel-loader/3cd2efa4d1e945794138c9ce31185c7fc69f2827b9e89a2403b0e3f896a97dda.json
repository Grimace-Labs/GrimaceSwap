{"ast":null,"code":"import { Contract, ethers } from \"ethers\";\nimport { fetchReserves, getDecimals } from \"../ethereumFunctions\";\nconst ERC20 = require(\"../build/ERC20.json\");\nconst PAIR = require(\"../build/IUniswapV2Pair.json\");\n\n// Function used to add Liquidity to any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to add from (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to add to (either a token or AUT)\n//    `amount1` - A float or similar number representing the value of address1's coin to add\n//    `amount2` - A float or similar number representing the value of address2's coin to add\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to add\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to add\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function addLiquidity(address1, address2, amount1, amount2, amount1min, amount2min, routerContract, account, signer) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n  const amountIn1 = ethers.utils.parseUnits(amount1, token1Decimals);\n  const amountIn2 = ethers.utils.parseUnits(amount2, token2Decimals);\n  const amount1Min = ethers.utils.parseUnits(amount1min, token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(amount2min, token2Decimals);\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  await token1.approve(routerContract.address, amountIn1);\n  await token2.approve(routerContract.address, amountIn2);\n  const wethAddress = await routerContract.WETH();\n  console.log([address1, address2, amountIn1, amountIn2, amount1Min, amount2Min, account, deadline]);\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.addLiquidityETH(address2, amountIn2, amount2Min, amount1Min, account, deadline, {\n      value: amountIn1\n    });\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.addLiquidityETH(address1, amountIn1, amount1Min, amount2Min, account, deadline, {\n      value: amountIn2\n    });\n  } else {\n    // Token + Token\n    await routerContract.addLiquidity(address1, address2, amountIn1, amountIn2, amount1Min, amount2Min, account, deadline);\n  }\n}\n\n// Function used to remove Liquidity from any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity_tokens` - A float or similar number representing the value of liquidity tokens you will burn to get tokens back\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to recieve\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to recieve\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function removeLiquidity(address1, address2, liquidity_tokens, amount1min, amount2min, routerContract, account, signer, factory) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n  const Getliquidity = liquidity_tokens => {\n    if (liquidity_tokens < 0.001) {\n      return ethers.BigNumber.from(liquidity_tokens * 10 ** 18);\n    }\n    return ethers.utils.parseUnits(String(liquidity_tokens), 18);\n  };\n  const liquidity = Getliquidity(liquidity_tokens);\n  console.log('liquidity: ', liquidity);\n  const amount1Min = ethers.utils.parseUnits(String(amount1min), token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(String(amount2min), token2Decimals);\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  const wethAddress = await routerContract.WETH();\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n  await pair.approve(routerContract.address, liquidity);\n  console.log([address1, address2, Number(liquidity), Number(amount1Min), Number(amount2Min), account, deadline]);\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.removeLiquidityETH(address2, liquidity, amount2Min, amount1Min, account, deadline);\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.removeLiquidityETH(address1, liquidity, amount1Min, amount2Min, account, deadline);\n  } else {\n    // Token + Token\n    await routerContract.removeLiquidity(address1, address2, liquidity, amount1Min, amount2Min, account, deadline);\n  }\n}\nconst quote = (amount1, reserve1, reserve2) => {\n  const amount2 = amount1 * (reserve2 / reserve1);\n  return [amount2];\n};\n\n// Function used to get a quote of the liquidity addition\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `amountA_desired` - The prefered value of the first token that the user would like to deploy as liquidity\n//    `amountB_desired` - The prefered value of the second token that the user would like to deploy as liquidity\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nasync function quoteMintLiquidity(address1, address2, amountA, amountB, factory, signer) {\n  const MINIMUM_LIQUIDITY = 1000;\n  let _reserveA = 0;\n  let _reserveB = 0;\n  let totalSupply = 0;\n  [_reserveA, _reserveB, totalSupply] = await factory.getPair(address1, address2).then(async pairAddress => {\n    if (pairAddress !== '0x0000000000000000000000000000000000000000') {\n      const pair = new Contract(pairAddress, PAIR.abi, signer);\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n      const reserveA = reservesRaw[0];\n      const reserveB = reservesRaw[1];\n      const _totalSupply = await pair.totalSupply();\n      const totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n      return [reserveA, reserveB, totalSupply];\n    } else {\n      return [0, 0, 0];\n    }\n  });\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  // Need to do all this decimals work to account for 0 decimal numbers\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n  const valueA = amountA * 10 ** token1Decimals;\n  const valueB = amountB * 10 ** token2Decimals;\n  const reserveA = _reserveA * 10 ** token1Decimals;\n  const reserveB = _reserveB * 10 ** token2Decimals;\n  if (totalSupply == 0) {\n    return Math.sqrt(valueA * valueB - MINIMUM_LIQUIDITY) * 10 ** -18;\n  }\n  ;\n  return Math.min(valueA * totalSupply / reserveA, valueB * totalSupply / reserveB);\n}\n;\nexport async function quoteAddLiquidity(address1, address2, amountADesired, amountBDesired, factory, signer) {\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n  if (reserveA === 0 && reserveB === 0) {\n    const amountOut = await quoteMintLiquidity(address1, address2, amountADesired, amountBDesired, factory, signer);\n    return [amountADesired, amountBDesired, amountOut.toPrecision(8)];\n  } else {\n    const amountBOptimal = quote(amountADesired, reserveA, reserveB);\n    if (amountBOptimal <= amountBDesired) {\n      const amountOut = await quoteMintLiquidity(address1, address2, amountADesired, amountBOptimal, factory, signer);\n      return [amountADesired, amountBOptimal, amountOut.toPrecision(8)];\n    } else {\n      const amountAOptimal = quote(amountBDesired, reserveB, reserveA);\n      const amountOut = await quoteMintLiquidity(address1, address2, amountAOptimal, amountBDesired, factory, signer);\n      return [amountAOptimal, amountBDesired, amountOut.toPrecision(8)];\n    }\n  }\n}\n\n// Function used to get a quote of the liquidity removal\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity` - The amount of liquidity tokens the user will burn to get their tokens back\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nexport async function quoteRemoveLiquidity(address1, address2, liquidity, factory, signer) {\n  const pairAddress = await factory.getPair(address1, address2);\n  console.log(\"pair address\", pairAddress);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n  const feeOn = (await factory.feeTo()) !== 0x0000000000000000000000000000000000000000;\n  const _kLast = await pair.kLast();\n  const kLast = Number(ethers.utils.formatEther(_kLast));\n  const _totalSupply = await pair.totalSupply();\n  let totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n  if (feeOn && kLast > 0) {\n    const feeLiquidity = totalSupply * (Math.sqrt(reserveA * reserveB) - Math.sqrt(kLast)) / (5 * Math.sqrt(reserveA * reserveB) + Math.sqrt(kLast));\n    totalSupply = totalSupply + feeLiquidity;\n  }\n  const Aout = reserveA * liquidity / totalSupply;\n  const Bout = reserveB * liquidity / totalSupply;\n  return [liquidity, Aout, Bout];\n}","map":{"version":3,"names":["Contract","ethers","fetchReserves","getDecimals","ERC20","require","PAIR","addLiquidity","address1","address2","amount1","amount2","amount1min","amount2min","routerContract","account","signer","token1","abi","token2","token1Decimals","token2Decimals","amountIn1","utils","parseUnits","amountIn2","amount1Min","amount2Min","time","Math","floor","Date","now","deadline","BigNumber","from","approve","address","wethAddress","WETH","console","log","addLiquidityETH","value","removeLiquidity","liquidity_tokens","factory","Getliquidity","String","liquidity","pairAddress","getPair","pair","Number","removeLiquidityETH","quote","reserve1","reserve2","quoteMintLiquidity","amountA","amountB","MINIMUM_LIQUIDITY","_reserveA","_reserveB","totalSupply","then","reservesRaw","reserveA","reserveB","_totalSupply","formatEther","valueA","valueB","sqrt","min","quoteAddLiquidity","amountADesired","amountBDesired","amountOut","toPrecision","amountBOptimal","amountAOptimal","quoteRemoveLiquidity","feeOn","feeTo","_kLast","kLast","feeLiquidity","Aout","Bout"],"sources":["D:/temki/grimace/GrimaceSwap/src/Liquidity/LiquidityFunctions.js"],"sourcesContent":["import { Contract, ethers } from \"ethers\";\r\nimport { fetchReserves, getDecimals } from \"../ethereumFunctions\";\r\n\r\nconst ERC20 = require(\"../build/ERC20.json\");\r\nconst PAIR = require(\"../build/IUniswapV2Pair.json\");\r\n\r\n// Function used to add Liquidity to any pair of tokens or token-AUT\r\n// To work correctly, there needs to be 9 arguments:\r\n//    `address1` - An Ethereum address of the coin to add from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the coin to add to (either a token or AUT)\r\n//    `amount1` - A float or similar number representing the value of address1's coin to add\r\n//    `amount2` - A float or similar number representing the value of address2's coin to add\r\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to add\r\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to add\r\n//    `routerContract` - The router contract to carry out this trade\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `provider` - The current provider\r\n//    `signer` - The current signer\r\nexport async function addLiquidity(\r\n  address1,\r\n  address2,\r\n  amount1,\r\n  amount2,\r\n  amount1min,\r\n  amount2min,\r\n  routerContract,\r\n  account,\r\n  signer\r\n) {\r\n  const token1 = new Contract(address1, ERC20.abi, signer);\r\n  const token2 = new Contract(address2, ERC20.abi, signer);\r\n\r\n  const token1Decimals = await getDecimals(token1);\r\n  const token2Decimals = await getDecimals(token2);\r\n\r\n  const amountIn1 = ethers.utils.parseUnits(amount1, token1Decimals);\r\n  const amountIn2 = ethers.utils.parseUnits(amount2, token2Decimals);\r\n\r\n  const amount1Min = ethers.utils.parseUnits(amount1min, token1Decimals);\r\n  const amount2Min = ethers.utils.parseUnits(amount2min, token2Decimals);\r\n\r\n  const time = Math.floor(Date.now() / 1000) + 200000;\r\n  const deadline = ethers.BigNumber.from(time);\r\n\r\n  await token1.approve(routerContract.address, amountIn1);\r\n  await token2.approve(routerContract.address, amountIn2);\r\n\r\n  const wethAddress = await routerContract.WETH();\r\n\r\n  console.log([\r\n    address1,\r\n    address2,\r\n    amountIn1,\r\n    amountIn2,\r\n    amount1Min,\r\n    amount2Min,\r\n    account,\r\n    deadline,\r\n  ]);\r\n\r\n  if (address1 === wethAddress) {\r\n    // Eth + Token\r\n    await routerContract.addLiquidityETH(\r\n      address2,\r\n      amountIn2,\r\n      amount2Min,\r\n      amount1Min,\r\n      account,\r\n      deadline,\r\n      { value: amountIn1 }\r\n    );\r\n  } else if (address2 === wethAddress) {\r\n    // Token + Eth\r\n    await routerContract.addLiquidityETH(\r\n      address1,\r\n      amountIn1,\r\n      amount1Min,\r\n      amount2Min,\r\n      account,\r\n      deadline,\r\n      { value: amountIn2 }\r\n    );\r\n  } else {\r\n    // Token + Token\r\n    await routerContract.addLiquidity(\r\n      address1,\r\n      address2,\r\n      amountIn1,\r\n      amountIn2,\r\n      amount1Min,\r\n      amount2Min,\r\n      account,\r\n      deadline\r\n    );\r\n  }\r\n}\r\n\r\n// Function used to remove Liquidity from any pair of tokens or token-AUT\r\n// To work correctly, there needs to be 9 arguments:\r\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\r\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\r\n//    `liquidity_tokens` - A float or similar number representing the value of liquidity tokens you will burn to get tokens back\r\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to recieve\r\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to recieve\r\n//    `routerContract` - The router contract to carry out this trade\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `provider` - The current provider\r\n//    `signer` - The current signer\r\nexport async function removeLiquidity(\r\n  address1,\r\n  address2,\r\n  liquidity_tokens,\r\n  amount1min,\r\n  amount2min,\r\n  routerContract,\r\n  account,\r\n  signer,\r\n  factory\r\n) {\r\n  const token1 = new Contract(address1, ERC20.abi, signer);\r\n  const token2 = new Contract(address2, ERC20.abi, signer);\r\n\r\n  const token1Decimals = await getDecimals(token1);\r\n  const token2Decimals = await getDecimals(token2);\r\n\r\n  const Getliquidity = (liquidity_tokens)=>{\r\n    if (liquidity_tokens < 0.001){\r\n      return ethers.BigNumber.from(liquidity_tokens*10**18);\r\n    }\r\n    return ethers.utils.parseUnits(String(liquidity_tokens), 18);\r\n  }\r\n\r\n  const liquidity = Getliquidity(liquidity_tokens);\r\n  console.log('liquidity: ', liquidity);\r\n\r\n  const amount1Min = ethers.utils.parseUnits(String(amount1min), token1Decimals);\r\n  const amount2Min = ethers.utils.parseUnits(String(amount2min), token2Decimals);\r\n\r\n  const time = Math.floor(Date.now() / 1000) + 200000;\r\n  const deadline = ethers.BigNumber.from(time);\r\n\r\n  const wethAddress = await routerContract.WETH();\r\n  const pairAddress = await factory.getPair(address1, address2);\r\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n\r\n  await pair.approve(routerContract.address, liquidity);\r\n\r\n  console.log([\r\n    address1,\r\n    address2,\r\n    Number(liquidity),\r\n    Number(amount1Min),\r\n    Number(amount2Min),\r\n    account,\r\n    deadline,\r\n  ]);\r\n\r\n  if (address1 === wethAddress) {\r\n    // Eth + Token\r\n    await routerContract.removeLiquidityETH(\r\n      address2,\r\n      liquidity,\r\n      amount2Min,\r\n      amount1Min,\r\n      account,\r\n      deadline\r\n    );\r\n  } else if (address2 === wethAddress) {\r\n    // Token + Eth\r\n    await routerContract.removeLiquidityETH(\r\n      address1,\r\n      liquidity,\r\n      amount1Min,\r\n      amount2Min,\r\n      account,\r\n      deadline\r\n    );\r\n  } else {\r\n    // Token + Token\r\n    await routerContract.removeLiquidity(\r\n      address1,\r\n      address2,\r\n      liquidity,\r\n      amount1Min,\r\n      amount2Min,\r\n      account,\r\n      deadline\r\n    );\r\n  }\r\n}\r\n\r\nconst quote = (amount1, reserve1, reserve2) => {\r\n  const amount2 = amount1 * (reserve2 / reserve1);\r\n  return [amount2];\r\n};\r\n\r\n// Function used to get a quote of the liquidity addition\r\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\r\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\r\n//    `amountA_desired` - The prefered value of the first token that the user would like to deploy as liquidity\r\n//    `amountB_desired` - The prefered value of the second token that the user would like to deploy as liquidity\r\n//    `factory` - The current factory\r\n//    `signer` - The current signer\r\n\r\nasync function quoteMintLiquidity(\r\n  address1,\r\n  address2,\r\n  amountA,\r\n  amountB,\r\n  factory,\r\n  signer\r\n){\r\n  const MINIMUM_LIQUIDITY = 1000;\r\n  let _reserveA = 0;\r\n  let _reserveB = 0;\r\n  let totalSupply = 0;\r\n  [_reserveA, _reserveB, totalSupply] = await factory.getPair(address1, address2).then(async (pairAddress) => {\r\n    if (pairAddress !== '0x0000000000000000000000000000000000000000'){\r\n      const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n\r\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\r\n      const reserveA = reservesRaw[0];\r\n      const reserveB = reservesRaw[1];\r\n    \r\n      const _totalSupply = await pair.totalSupply();\r\n      const totalSupply = Number(ethers.utils.formatEther(_totalSupply));\r\n      return [reserveA, reserveB, totalSupply]\r\n    } else {\r\n      return [0,0,0]\r\n    }\r\n  });\r\n\r\n  const token1 = new Contract(address1, ERC20.abi, signer);\r\n  const token2 = new Contract(address2, ERC20.abi, signer);\r\n\r\n  // Need to do all this decimals work to account for 0 decimal numbers\r\n\r\n  const token1Decimals = await getDecimals(token1);\r\n  const token2Decimals = await getDecimals(token2);\r\n\r\n  const valueA = amountA*(10**token1Decimals);\r\n  const valueB = amountB*(10**token2Decimals);\r\n\r\n  const reserveA = _reserveA*(10**token1Decimals);\r\n  const reserveB = _reserveB*(10**token2Decimals);\r\n\r\n  if (totalSupply == 0){\r\n    return Math.sqrt(((valueA * valueB)-MINIMUM_LIQUIDITY))*10**(-18);\r\n  };\r\n  \r\n  return (\r\n    Math.min(valueA*totalSupply/reserveA, valueB*totalSupply/reserveB)\r\n  );\r\n};\r\n\r\nexport async function quoteAddLiquidity(\r\n  address1,\r\n  address2,\r\n  amountADesired,\r\n  amountBDesired,\r\n  factory,\r\n  signer\r\n) {\r\n\r\n  const pairAddress = await factory.getPair(address1, address2);\r\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n\r\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\r\n  const reserveA = reservesRaw[0];\r\n  const reserveB = reservesRaw[1];\r\n\r\n  if (reserveA === 0 && reserveB === 0) {\r\n    const amountOut = await quoteMintLiquidity(\r\n      address1,\r\n      address2,\r\n      amountADesired,\r\n      amountBDesired,\r\n      factory,\r\n      signer);\r\n    return [\r\n      amountADesired,\r\n      amountBDesired,\r\n      amountOut.toPrecision(8),\r\n    ];\r\n  } else {\r\n    const amountBOptimal = quote(amountADesired, reserveA, reserveB);\r\n    if (amountBOptimal <= amountBDesired) {\r\n      const amountOut = await quoteMintLiquidity(\r\n        address1,\r\n        address2,\r\n        amountADesired,\r\n        amountBOptimal,\r\n        factory,\r\n        signer);\r\n      return [\r\n        amountADesired,\r\n        amountBOptimal,\r\n        amountOut.toPrecision(8),\r\n      ];\r\n    } else {\r\n      const amountAOptimal = quote(\r\n        amountBDesired,\r\n        reserveB,\r\n        reserveA\r\n      );\r\n      const amountOut = await quoteMintLiquidity(\r\n        address1,\r\n        address2,\r\n        amountAOptimal,\r\n        amountBDesired,\r\n        factory,\r\n        signer);\r\n      return [\r\n        amountAOptimal,\r\n        amountBDesired,\r\n        amountOut.toPrecision(8),\r\n      ];\r\n    }\r\n  }\r\n}\r\n\r\n// Function used to get a quote of the liquidity removal\r\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\r\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\r\n//    `liquidity` - The amount of liquidity tokens the user will burn to get their tokens back\r\n//    `factory` - The current factory\r\n//    `signer` - The current signer\r\n\r\nexport async function quoteRemoveLiquidity(\r\n  address1,\r\n  address2,\r\n  liquidity,\r\n  factory,\r\n  signer\r\n) {\r\n  const pairAddress = await factory.getPair(address1, address2);\r\n  console.log(\"pair address\", pairAddress);\r\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n\r\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\r\n  const reserveA = reservesRaw[0];\r\n  const reserveB = reservesRaw[1];\r\n\r\n  const feeOn =\r\n    (await factory.feeTo()) !== 0x0000000000000000000000000000000000000000;\r\n\r\n  const _kLast = await pair.kLast();\r\n  const kLast = Number(ethers.utils.formatEther(_kLast));\r\n\r\n  const _totalSupply = await pair.totalSupply();\r\n  let totalSupply = Number(ethers.utils.formatEther(_totalSupply));\r\n\r\n  if (feeOn && kLast > 0) {\r\n    const feeLiquidity =\r\n      (totalSupply * (Math.sqrt(reserveA * reserveB) - Math.sqrt(kLast))) /\r\n      (5 * Math.sqrt(reserveA * reserveB) + Math.sqrt(kLast));\r\n    totalSupply = totalSupply + feeLiquidity;\r\n  }\r\n\r\n  const Aout = (reserveA * liquidity) / totalSupply;\r\n  const Bout = (reserveB * liquidity) / totalSupply;\r\n\r\n  return [liquidity, Aout, Bout];\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}