{"ast":null,"code":"\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n///////////////////////////////\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n  return array;\n}\nexport function isBytesLike(value) {\n  return isHexString(value) && !(value.length % 2) || isBytes(value);\n}\nexport function isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n  if (typeof value === \"string\") {\n    return false;\n  }\n  if (value.length == null) {\n    return false;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n    if (typeof v !== \"number\" || v < 0 || v >= 256 || v % 1) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid arrayify value\");\n    var result = [];\n    while (value) {\n      result.unshift(value & 0xff);\n      value = parseInt(String(value / 256));\n    }\n    if (result.length === 0) {\n      result.push(0);\n    }\n    return addSlice(new Uint8Array(result));\n  }\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n  if (isHexString(value)) {\n    var hex = value.substring(2);\n    if (hex.length % 2) {\n      if (options.hexPad === \"left\") {\n        hex = \"0x0\" + hex.substring(2);\n      } else if (options.hexPad === \"right\") {\n        hex += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n    var _result = [];\n    for (var i = 0; i < hex.length; i += 2) {\n      _result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n    return addSlice(new Uint8Array(_result));\n  }\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n  return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexport function concat(items) {\n  var objects = items.map(function (item) {\n    return arrayify(item);\n  });\n  var length = objects.reduce(function (accum, item) {\n    return accum + item.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  objects.reduce(function (offset, object) {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n  return addSlice(result);\n}\nexport function stripZeros(value) {\n  var result = arrayify(value);\n  if (result.length === 0) {\n    return result;\n  }\n  // Find the first non-zero entry\n  var start = 0;\n  while (start < result.length && result[start] === 0) {\n    start++;\n  }\n  // If we started with zeros, strip them\n  if (start) {\n    result = result.slice(start);\n  }\n  return result;\n}\nexport function zeroPad(value, length) {\n  value = arrayify(value);\n  if (value.length > length) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n  }\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\nexport function isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\nvar HexCharacters = \"0123456789abcdef\";\nexport function hexlify(value, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid hexlify value\");\n    var hex = \"\";\n    while (value) {\n      hex = HexCharacters[value & 0xf] + hex;\n      value = Math.floor(value / 16);\n    }\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = \"0\" + hex;\n      }\n      return \"0x\" + hex;\n    }\n    return \"0x00\";\n  }\n  if (typeof value === \"bigint\") {\n    value = value.toString(16);\n    if (value.length % 2) {\n      return \"0x0\" + value;\n    }\n    return \"0x\" + value;\n  }\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n  if (isHexString(value)) {\n    if (value.length % 2) {\n      if (options.hexPad === \"left\") {\n        value = \"0x0\" + value.substring(2);\n      } else if (options.hexPad === \"right\") {\n        value += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n    return value.toLowerCase();\n  }\n  if (isBytes(value)) {\n    var result = \"0x\";\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n  }\n  return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    return null;\n  }\n  return (data.length - 2) / 2;\n}\nexport function hexDataSlice(data, offset, endOffset) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n  }\n  offset = 2 + 2 * offset;\n  if (endOffset != null) {\n    return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n  }\n  return \"0x\" + data.substring(offset);\n}\nexport function hexConcat(items) {\n  var result = \"0x\";\n  items.forEach(function (item) {\n    result += hexlify(item).substring(2);\n  });\n  return result;\n}\nexport function hexValue(value) {\n  var trimmed = hexStripZeros(hexlify(value, {\n    hexPad: \"left\"\n  }));\n  if (trimmed === \"0x\") {\n    return \"0x0\";\n  }\n  return trimmed;\n}\nexport function hexStripZeros(value) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  }\n  if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n  value = value.substring(2);\n  var offset = 0;\n  while (offset < value.length && value[offset] === \"0\") {\n    offset++;\n  }\n  return \"0x\" + value.substring(offset);\n}\nexport function hexZeroPad(value, length) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  } else if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n  if (value.length > 2 * length + 2) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n  }\n  while (value.length < 2 * length + 2) {\n    value = \"0x0\" + value.substring(2);\n  }\n  return value;\n}\nexport function splitSignature(signature) {\n  var result = {\n    r: \"0x\",\n    s: \"0x\",\n    _vs: \"0x\",\n    recoveryParam: 0,\n    v: 0\n  };\n  if (isBytesLike(signature)) {\n    var bytes = arrayify(signature);\n    if (bytes.length !== 65) {\n      logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n    }\n    // Get the r, s and v\n    result.r = hexlify(bytes.slice(0, 32));\n    result.s = hexlify(bytes.slice(32, 64));\n    result.v = bytes[64];\n    // Allow a recid to be used as the v\n    if (result.v < 27) {\n      if (result.v === 0 || result.v === 1) {\n        result.v += 27;\n      } else {\n        logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n      }\n    }\n    // Compute recoveryParam from v\n    result.recoveryParam = 1 - result.v % 2;\n    // Compute _vs from recoveryParam and s\n    if (result.recoveryParam) {\n      bytes[32] |= 0x80;\n    }\n    result._vs = hexlify(bytes.slice(32, 64));\n  } else {\n    result.r = signature.r;\n    result.s = signature.s;\n    result.v = signature.v;\n    result.recoveryParam = signature.recoveryParam;\n    result._vs = signature._vs;\n    // If the _vs is available, use it to populate missing s, v and recoveryParam\n    // and verify non-missing s, v and recoveryParam\n    if (result._vs != null) {\n      var _vs2 = zeroPad(arrayify(result._vs), 32);\n      result._vs = hexlify(_vs2);\n      // Set or check the recid\n      var recoveryParam = _vs2[0] >= 128 ? 1 : 0;\n      if (result.recoveryParam == null) {\n        result.recoveryParam = recoveryParam;\n      } else if (result.recoveryParam !== recoveryParam) {\n        logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n      }\n      // Set or check the s\n      _vs2[0] &= 0x7f;\n      var s = hexlify(_vs2);\n      if (result.s == null) {\n        result.s = s;\n      } else if (result.s !== s) {\n        logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n      }\n    }\n    // Use recid and v to populate each other\n    if (result.recoveryParam == null) {\n      if (result.v == null) {\n        logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n      } else if (result.v === 0 || result.v === 1) {\n        result.recoveryParam = result.v;\n      } else {\n        result.recoveryParam = 1 - result.v % 2;\n      }\n    } else {\n      if (result.v == null) {\n        result.v = 27 + result.recoveryParam;\n      } else if (result.recoveryParam !== 1 - result.v % 2) {\n        logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n      }\n    }\n    if (result.r == null || !isHexString(result.r)) {\n      logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n    } else {\n      result.r = hexZeroPad(result.r, 32);\n    }\n    if (result.s == null || !isHexString(result.s)) {\n      logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n    } else {\n      result.s = hexZeroPad(result.s, 32);\n    }\n    var vs = arrayify(result.s);\n    if (vs[0] >= 128) {\n      logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n    }\n    if (result.recoveryParam) {\n      vs[0] |= 0x80;\n    }\n    var _vs = hexlify(vs);\n    if (result._vs) {\n      if (!isHexString(result._vs)) {\n        logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n      }\n      result._vs = hexZeroPad(result._vs, 32);\n    }\n    // Set or check the _vs\n    if (result._vs == null) {\n      result._vs = _vs;\n    } else if (result._vs !== _vs) {\n      logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n    }\n  }\n  return result;\n}\nexport function joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? \"0x1c\" : \"0x1b\"]));\n}","map":{"version":3,"names":["Logger","version","logger","isHexable","value","toHexString","addSlice","array","slice","args","Array","prototype","call","arguments","Uint8Array","apply","isBytesLike","isHexString","length","isBytes","constructor","i","v","arrayify","options","checkSafeUint53","result","unshift","parseInt","String","push","allowMissingPrefix","substring","hex","hexPad","throwArgumentError","concat","items","objects","map","item","reduce","accum","offset","object","set","stripZeros","start","zeroPad","match","HexCharacters","hexlify","Math","floor","toString","toLowerCase","hexDataLength","data","hexDataSlice","endOffset","hexConcat","forEach","hexValue","trimmed","hexStripZeros","hexZeroPad","splitSignature","signature","r","s","_vs","recoveryParam","bytes","vs","joinSignature"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\ethers\\node_modules\\@ethersproject\\bytes\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (value.length == null) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (typeof(v) !== \"number\" || v < 0 || v >= 256 || (v % 1)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0\n    };\n\n    if (isBytesLike(signature)) {\n        const bytes: Uint8Array = arrayify(signature);\n        if (bytes.length !== 65) {\n            logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n        }\n\n        // Get the r, s and v\n        result.r = hexlify(bytes.slice(0, 32));\n        result.s = hexlify(bytes.slice(32, 64));\n        result.v = bytes[64];\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else if (result.recoveryParam !== (1 - (result.v % 2))) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}