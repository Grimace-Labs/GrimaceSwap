{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n  for (let i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n  return null;\n}\nexport function resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const promises = Object.keys(object).map(key => {\n      const value = object[key];\n      return Promise.resolve(value).then(v => ({\n        key: key,\n        value: v\n      }));\n    });\n    const results = yield Promise.all(promises);\n    return results.reduce((accum, result) => {\n      accum[result.key] = result.value;\n      return accum;\n    }, {});\n  });\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n  Object.keys(object).forEach(key => {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  const result = {};\n  for (const key in object) {\n    result[key] = object[key];\n  }\n  return result;\n}\nconst opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n    const keys = Object.keys(object);\n    for (let i = 0; i < keys.length; i++) {\n      if (!_isFrozen(object[keys[i]])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  }\n  // Arrays are mutable, so we need to create a copy\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(item => deepCopy(item)));\n  }\n  if (typeof object === \"object\") {\n    const result = {};\n    for (const key in object) {\n      const value = object[key];\n      if (value === undefined) {\n        continue;\n      }\n      defineReadOnly(result, key, deepCopy(value));\n    }\n    return result;\n  }\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport class Description {\n  constructor(info) {\n    for (const key in info) {\n      this[key] = deepCopy(info[key]);\n    }\n  }\n}","map":{"version":3,"names":["Logger","version","logger","defineReadOnly","object","name","value","Object","defineProperty","enumerable","writable","getStatic","ctor","key","i","prototype","getPrototypeOf","constructor","resolveProperties","promises","keys","map","Promise","resolve","then","v","results","all","reduce","accum","result","checkProperties","properties","throwArgumentError","forEach","shallowCopy","opaque","bigint","boolean","number","string","_isFrozen","undefined","Array","isArray","isFrozen","length","_deepCopy","freeze","item","deepCopy","Description","info"],"sources":["D:\\temki\\grimace\\GrimaceSwap\\node_modules\\ethers\\node_modules\\@ethersproject\\properties\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            if (!_isFrozen(object[keys[i]])) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}